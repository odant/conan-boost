diff --git a/boost_1_82_0/boost/filesystem/config.hpp b/boost_1_82_0/boost/filesystem/config.hpp
index bd414ef5d7..fed4e0ab58 100644
--- a/boost_1_82_0/boost/filesystem/config.hpp
+++ b/boost_1_82_0/boost/filesystem/config.hpp
@@ -70,8 +70,47 @@
 // Deprecated symbols markup -----------------------------------------------------------//
 
 #if !defined(BOOST_FILESYSTEM_ALLOW_DEPRECATED)
-#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) BOOST_DEPRECATED(msg)
+
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED) && defined(_MSC_VER)
+#if (_MSC_VER) >= 1400
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) __declspec(deprecated(msg))
 #else
+// MSVC 7.1 only supports the attribute without a message
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) __declspec(deprecated)
+#endif
+#endif
+
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED) && defined(__has_extension)
+#if __has_extension(attribute_deprecated_with_message)
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) __attribute__((deprecated(msg)))
+#endif
+#endif
+
+// gcc since 4.5 supports deprecated attribute with a message; older versions support the attribute without a message.
+// Oracle Studio 12.4 supports deprecated attribute with a message; this is the first release that supports the attribute.
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED) && (\
+    (defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) >= 405) ||\
+    (defined(__SUNPRO_CC) && __SUNPRO_CC >= 0x5130))
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) __attribute__((deprecated(msg)))
+#endif
+
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED) && __cplusplus >= 201402
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) [[deprecated(msg)]]
+#endif
+
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED) && defined(__GNUC__)
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) __attribute__((deprecated))
+#endif
+
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED) && defined(__has_attribute)
+#if __has_attribute(deprecated)
+#define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg) __attribute__((deprecated))
+#endif
+#endif
+
+#endif // !defined(BOOST_FILESYSTEM_ALLOW_DEPRECATED)
+
+#if !defined(BOOST_FILESYSTEM_DETAIL_DEPRECATED)
 #define BOOST_FILESYSTEM_DETAIL_DEPRECATED(msg)
 #endif
 
diff --git a/boost_1_82_0/boost/filesystem/detail/header.hpp b/boost_1_82_0/boost/filesystem/detail/header.hpp
index f98b0aba95..9ee6fc8c60 100644
--- a/boost_1_82_0/boost/filesystem/detail/header.hpp
+++ b/boost_1_82_0/boost/filesystem/detail/header.hpp
@@ -44,11 +44,6 @@
 // unused function 'foo'
 #pragma GCC diagnostic ignored "-Wunused-function"
 
-#if defined(__clang__)
-// template argument uses unnamed type
-#pragma clang diagnostic ignored "-Wunnamed-type-template-args"
-#endif // defined(__clang__)
-
 #endif
 
 #endif // !defined(BOOST_FILESYSTEM_ENABLE_WARNINGS)
diff --git a/boost_1_82_0/boost/filesystem/detail/path_traits.hpp b/boost_1_82_0/boost/filesystem/detail/path_traits.hpp
index c32defff90..0840c1edd9 100644
--- a/boost_1_82_0/boost/filesystem/detail/path_traits.hpp
+++ b/boost_1_82_0/boost/filesystem/detail/path_traits.hpp
@@ -398,37 +398,37 @@ void convert(const wchar_t* from, const wchar_t* from_end, std::string& to, cons
 //  Source dispatch  -----------------------------------------------------------------//
 
 template< typename Source, typename Callback >
-typename Callback::result_type dispatch(Source const& source, Callback cb, const codecvt_type* cvt = NULL);
+inline void dispatch(Source const& source, Callback cb, const codecvt_type* cvt = NULL);
 
 template< typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(const char* source, Callback cb, const codecvt_type* cvt, ntcts_type_tag)
+BOOST_FORCEINLINE void dispatch(const char* source, Callback cb, const codecvt_type* cvt, ntcts_type_tag)
 {
-    return cb(source, source + std::strlen(source), cvt);
+    cb(source, source + std::strlen(source), cvt);
 }
 
 template< typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(const wchar_t* source, Callback cb, const codecvt_type* cvt, ntcts_type_tag)
+BOOST_FORCEINLINE void dispatch(const wchar_t* source, Callback cb, const codecvt_type* cvt, ntcts_type_tag)
 {
-    return cb(source, source + std::wcslen(source), cvt);
+    cb(source, source + std::wcslen(source), cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(Source const& source, Callback cb, const codecvt_type* cvt, string_class_tag)
+BOOST_FORCEINLINE void dispatch(Source const& source, Callback cb, const codecvt_type* cvt, string_class_tag)
 {
-    return cb(source.data(), source.data() + source.size(), cvt);
+    cb(source.data(), source.data() + source.size(), cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(Source const& source, Callback cb, const codecvt_type* cvt, range_type_tag)
+BOOST_FORCEINLINE void dispatch(Source const& source, Callback cb, const codecvt_type* cvt, range_type_tag)
 {
     std::basic_string< typename Source::value_type > src(source.begin(), source.end());
-    return cb(src.data(), src.data() + src.size(), cvt);
+    cb(src.data(), src.data() + src.size(), cvt);
 }
 
 #if !defined(BOOST_FILESYSTEM_NO_DEPRECATED) && BOOST_FILESYSTEM_VERSION < 4
 
 template< typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(std::vector< char > const& source, Callback cb, const codecvt_type* cvt, range_type_tag)
+BOOST_FORCEINLINE void dispatch(std::vector< char > const& source, Callback cb, const codecvt_type* cvt, range_type_tag)
 {
     const char* data = NULL, *data_end = NULL;
     if (!source.empty())
@@ -436,11 +436,11 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch(std::vector< char > co
         data = &source[0];
         data_end = data + source.size();
     }
-    return cb(data, data_end, cvt);
+    cb(data, data_end, cvt);
 }
 
 template< typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(std::vector< wchar_t > const& source, Callback cb, const codecvt_type* cvt, range_type_tag)
+BOOST_FORCEINLINE void dispatch(std::vector< wchar_t > const& source, Callback cb, const codecvt_type* cvt, range_type_tag)
 {
     const wchar_t* data = NULL, *data_end = NULL;
     if (!source.empty())
@@ -448,19 +448,19 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch(std::vector< wchar_t >
         data = &source[0];
         data_end = data + source.size();
     }
-    return cb(data, data_end, cvt);
+    cb(data, data_end, cvt);
 }
 
 #endif // !defined(BOOST_FILESYSTEM_NO_DEPRECATED) && BOOST_FILESYSTEM_VERSION < 4
 
 // Defined in directory.hpp to avoid circular header dependencies
 template< typename Callback >
-typename Callback::result_type dispatch(directory_entry const& de, Callback cb, const codecvt_type* cvt, directory_entry_tag);
+void dispatch(directory_entry const& de, Callback cb, const codecvt_type* cvt, directory_entry_tag);
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(Source const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch(Source const& source, Callback cb, const codecvt_type* cvt)
 {
-    return path_traits::dispatch(source, cb, cvt,
+    path_traits::dispatch(source, cb, cvt,
         typename path_traits::path_source_traits< typename boost::remove_cv< Source >::type >::tag_type());
 }
 
@@ -489,9 +489,6 @@ struct is_convertible_to_path_source
 #endif
     static yes_type _check_convertible_to_path_source(boost::basic_string_view< char, std::char_traits< char > > const&);
     static yes_type _check_convertible_to_path_source(boost::basic_string_view< wchar_t, std::char_traits< wchar_t > > const&);
-#if !defined(BOOST_NO_CXX11_NULLPTR)
-    static no_type _check_convertible_to_path_source(std::nullptr_t);
-#endif
     static no_type _check_convertible_to_path_source(...);
 
     static BOOST_CONSTEXPR_OR_CONST bool value =
@@ -511,9 +508,6 @@ struct is_convertible_to_std_string_view
 {
     static yes_type _check_convertible_to_std_string_view(std::string_view const&);
     static yes_type _check_convertible_to_std_string_view(std::wstring_view const&);
-#if !defined(BOOST_NO_CXX11_NULLPTR)
-    static no_type _check_convertible_to_std_string_view(std::nullptr_t);
-#endif
     static no_type _check_convertible_to_std_string_view(...);
 
     static BOOST_CONSTEXPR_OR_CONST bool value =
@@ -532,9 +526,6 @@ struct is_convertible_to_path_source_non_std_string_view
     static yes_type _check_convertible_to_path_source(boost::container::basic_string< wchar_t, std::char_traits< wchar_t >, void > const&);
     static yes_type _check_convertible_to_path_source(boost::basic_string_view< char, std::char_traits< char > > const&);
     static yes_type _check_convertible_to_path_source(boost::basic_string_view< wchar_t, std::char_traits< wchar_t > > const&);
-#if !defined(BOOST_NO_CXX11_NULLPTR)
-    static no_type _check_convertible_to_path_source(std::nullptr_t);
-#endif
     static no_type _check_convertible_to_path_source(...);
 
     static BOOST_CONSTEXPR_OR_CONST bool value =
@@ -561,35 +552,35 @@ struct make_dependent
 };
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl(const char* source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_impl(const char* source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< const char*, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl(const wchar_t* source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_impl(const wchar_t* source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< const wchar_t*, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl(std::string const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_impl(std::string const& source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< std::string, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl(std::wstring const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_impl(std::wstring const& source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< std::wstring, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
+BOOST_FORCEINLINE void dispatch_convertible_impl
 (
     boost::container::basic_string< char, std::char_traits< char >, void > const& source,
     Callback cb,
@@ -597,11 +588,11 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
 )
 {
     typedef typename path_traits::make_dependent< boost::container::basic_string< char, std::char_traits< char >, void >, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
+BOOST_FORCEINLINE void dispatch_convertible_impl
 (
     boost::container::basic_string< wchar_t, std::char_traits< wchar_t >, void > const& source,
     Callback cb,
@@ -609,11 +600,11 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
 )
 {
     typedef typename path_traits::make_dependent< boost::container::basic_string< wchar_t, std::char_traits< wchar_t >, void >, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
+BOOST_FORCEINLINE void dispatch_convertible_impl
 (
     boost::basic_string_view< char, std::char_traits< char > > const& source,
     Callback cb,
@@ -621,11 +612,11 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
 )
 {
     typedef typename path_traits::make_dependent< boost::basic_string_view< char, std::char_traits< char > >, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
+BOOST_FORCEINLINE void dispatch_convertible_impl
 (
     boost::basic_string_view< wchar_t, std::char_traits< wchar_t > > const& source,
     Callback cb,
@@ -633,7 +624,7 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
 )
 {
     typedef typename path_traits::make_dependent< boost::basic_string_view< wchar_t, std::char_traits< wchar_t > >, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 #if !defined(BOOST_FILESYSTEM_CXX23_STRING_VIEW_HAS_IMPLICIT_RANGE_CTOR)
@@ -641,62 +632,60 @@ BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl
 #if !defined(BOOST_NO_CXX17_HDR_STRING_VIEW)
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl(std::string_view const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_impl(std::string_view const& source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< std::string_view, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_impl(std::wstring_view const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_impl(std::wstring_view const& source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< std::wstring_view, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 #endif // !defined(BOOST_NO_CXX17_HDR_STRING_VIEW)
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible(Source const& source, Callback cb, const codecvt_type* cvt = NULL)
+BOOST_FORCEINLINE void dispatch_convertible(Source const& source, Callback cb, const codecvt_type* cvt = NULL)
 {
     typedef typename boost::remove_cv< Source >::type source_t;
-    return path_traits::dispatch_convertible_impl< source_t >(source, cb, cvt);
+    path_traits::dispatch_convertible_impl< source_t >(source, cb, cvt);
 }
 
 #else // !defined(BOOST_FILESYSTEM_CXX23_STRING_VIEW_HAS_IMPLICIT_RANGE_CTOR)
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_sv_impl(std::string_view const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_sv_impl(std::string_view const& source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< std::string_view, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch_convertible_sv_impl(std::wstring_view const& source, Callback cb, const codecvt_type* cvt)
+BOOST_FORCEINLINE void dispatch_convertible_sv_impl(std::wstring_view const& source, Callback cb, const codecvt_type* cvt)
 {
     typedef typename path_traits::make_dependent< std::wstring_view, Source >::type source_t;
-    return path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
+    path_traits::dispatch(static_cast< source_t const& >(source), cb, cvt);
 }
 
 template< typename Source, typename Callback >
 BOOST_FORCEINLINE typename boost::disable_if_c<
-    is_convertible_to_std_string_view< typename boost::remove_cv< Source >::type >::value,
-    typename Callback::result_type
+    is_convertible_to_std_string_view< typename boost::remove_cv< Source >::type >::value
 >::type dispatch_convertible(Source const& source, Callback cb, const codecvt_type* cvt = NULL)
 {
     typedef typename boost::remove_cv< Source >::type source_t;
-    return path_traits::dispatch_convertible_impl< source_t >(source, cb, cvt);
+    path_traits::dispatch_convertible_impl< source_t >(source, cb, cvt);
 }
 
 template< typename Source, typename Callback >
 BOOST_FORCEINLINE typename boost::enable_if_c<
-    is_convertible_to_std_string_view< typename boost::remove_cv< Source >::type >::value,
-    typename Callback::result_type
+    is_convertible_to_std_string_view< typename boost::remove_cv< Source >::type >::value
 >::type dispatch_convertible(Source const& source, Callback cb, const codecvt_type* cvt = NULL)
 {
     typedef typename boost::remove_cv< Source >::type source_t;
-    return path_traits::dispatch_convertible_sv_impl< source_t >(source, cb, cvt);
+    path_traits::dispatch_convertible_sv_impl< source_t >(source, cb, cvt);
 }
 
 #endif // !defined(BOOST_FILESYSTEM_CXX23_STRING_VIEW_HAS_IMPLICIT_RANGE_CTOR)
diff --git a/boost_1_82_0/boost/filesystem/directory.hpp b/boost_1_82_0/boost/filesystem/directory.hpp
index 64c6116489..c499006db7 100644
--- a/boost_1_82_0/boost/filesystem/directory.hpp
+++ b/boost_1_82_0/boost/filesystem/directory.hpp
@@ -123,7 +123,8 @@ public:
 
     void replace_filename(boost::filesystem::path const& p, file_status st = file_status(), file_status symlink_st = file_status())
     {
-        m_path.replace_filename(p);
+        m_path.remove_filename();
+        m_path /= p;
 #if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
         m_status = static_cast< file_status&& >(st);
         m_symlink_status = static_cast< file_status&& >(symlink_st);
@@ -173,10 +174,10 @@ namespace path_traits {
 
 // Dispatch function for integration with path class
 template< typename Callback >
-BOOST_FORCEINLINE typename Callback::result_type dispatch(directory_entry const& de, Callback cb, const codecvt_type* cvt, directory_entry_tag)
+BOOST_FORCEINLINE void dispatch(directory_entry const& de, Callback cb, const codecvt_type* cvt, directory_entry_tag)
 {
     boost::filesystem::path::string_type const& source = de.path().native();
-    return cb(source.data(), source.data() + source.size(), cvt);
+    cb(source.data(), source.data() + source.size(), cvt);
 }
 
 } // namespace path_traits
@@ -275,13 +276,13 @@ inline bool is_regular(directory_entry const& e)
 BOOST_SCOPED_ENUM_UT_DECLARE_BEGIN(directory_options, unsigned int)
 {
     none = 0u,
-    skip_permission_denied = 1u,         // if a directory cannot be opened because of insufficient permissions, pretend that the directory is empty
-    follow_directory_symlink = 1u << 1u, // recursive_directory_iterator: follow directory symlinks
-    skip_dangling_symlinks = 1u << 2u,   // non-standard extension for recursive_directory_iterator: don't follow dangling directory symlinks,
-    pop_on_error = 1u << 3u,             // non-standard extension for recursive_directory_iterator: instead of producing an end iterator on errors,
-                                         // repeatedly invoke pop() until it succeeds or the iterator becomes equal to end iterator
-    _detail_no_follow = 1u << 4u,        // internal use only
-    _detail_no_push = 1u << 5u           // internal use only
+    skip_permission_denied = 1u,        // if a directory cannot be opened because of insufficient permissions, pretend that the directory is empty
+    follow_directory_symlink = 1u << 1, // recursive_directory_iterator: follow directory symlinks
+    skip_dangling_symlinks = 1u << 2,   // non-standard extension for recursive_directory_iterator: don't follow dangling directory symlinks,
+    pop_on_error = 1u << 3,             // non-standard extension for recursive_directory_iterator: instead of producing an end iterator on errors,
+                                        // repeatedly invoke pop() until it succeeds or the iterator becomes equal to end iterator
+    _detail_no_follow = 1u << 4,        // internal use only
+    _detail_no_push = 1u << 5           // internal use only
 }
 BOOST_SCOPED_ENUM_DECLARE_END(directory_options)
 
diff --git a/boost_1_82_0/boost/filesystem/path.hpp b/boost_1_82_0/boost/filesystem/path.hpp
index 61278ef749..fe29a9bd75 100644
--- a/boost_1_82_0/boost/filesystem/path.hpp
+++ b/boost_1_82_0/boost/filesystem/path.hpp
@@ -2,7 +2,7 @@
 
 //  Copyright Vladimir Prus 2002
 //  Copyright Beman Dawes 2002-2005, 2009
-//  Copyright Andrey Semashev 2021-2023
+//  Copyright Andrey Semashev 2021
 
 //  Distributed under the Boost Software License, Version 1.0.
 //  See http://www.boost.org/LICENSE_1_0.txt
@@ -43,8 +43,6 @@
 namespace boost {
 namespace filesystem {
 
-class path;
-
 namespace path_detail { // intentionally don't use filesystem::detail to not bring internal Boost.Filesystem functions into ADL via path_constants
 
 template< typename Char, Char Separator, Char PreferredSeparator, Char Dot >
@@ -69,82 +67,14 @@ BOOST_CONSTEXPR_OR_CONST typename path_constants< Char, Separator, PreferredSepa
 path_constants< Char, Separator, PreferredSeparator, Dot >::dot;
 #endif
 
-class path_iterator;
-class path_reverse_iterator;
-
-} // namespace path_detail
-
-namespace detail {
-
-struct path_algorithms
+// A struct that denotes a contiguous range of characters in a string. A lightweight alternative to string_view.
+struct substring
 {
-    // A struct that denotes a contiguous range of characters in a string. A lightweight alternative to string_view.
-    struct substring
-    {
-        std::size_t pos;
-        std::size_t size;
-    };
-
-    typedef path_traits::path_native_char_type value_type;
-    typedef std::basic_string< value_type > string_type;
-
-    static bool has_filename_v3(path const& p);
-    static bool has_filename_v4(path const& p);
-    BOOST_FILESYSTEM_DECL static path filename_v3(path const& p);
-    static path filename_v4(path const& p);
-
-    BOOST_FILESYSTEM_DECL static path stem_v3(path const& p);
-    BOOST_FILESYSTEM_DECL static path stem_v4(path const& p);
-    BOOST_FILESYSTEM_DECL static path extension_v3(path const& p);
-    static path extension_v4(path const& p);
-
-    BOOST_FILESYSTEM_DECL static void remove_filename_v3(path& p);
-    BOOST_FILESYSTEM_DECL static void remove_filename_v4(path& p);
-
-    BOOST_FILESYSTEM_DECL static void replace_extension_v3(path& p, path const& new_extension);
-    BOOST_FILESYSTEM_DECL static void replace_extension_v4(path& p, path const& new_extension);
-
-    BOOST_FILESYSTEM_DECL static path lexically_normal_v3(path const& p);
-    BOOST_FILESYSTEM_DECL static path lexically_normal_v4(path const& p);
-
-    BOOST_FILESYSTEM_DECL static int compare_v3(path const& left, path const& right);
-    BOOST_FILESYSTEM_DECL static int compare_v4(path const& left, path const& right);
-
-    BOOST_FILESYSTEM_DECL static void append_v3(path& p, const value_type* b, const value_type* e);
-    BOOST_FILESYSTEM_DECL static void append_v4(path& p, const value_type* b, const value_type* e);
-    static void append_v4(path& left, path const& right);
-
-    //  Returns: If separator is to be appended, m_pathname.size() before append. Otherwise 0.
-    //  Note: An append is never performed if size()==0, so a returned 0 is unambiguous.
-    BOOST_FILESYSTEM_DECL static string_type::size_type append_separator_if_needed(path& p);
-    BOOST_FILESYSTEM_DECL static void erase_redundant_separator(path& p, string_type::size_type sep_pos);
-
-    BOOST_FILESYSTEM_DECL static string_type::size_type find_root_name_size(path const& p);
-    BOOST_FILESYSTEM_DECL static string_type::size_type find_root_path_size(path const& p);
-    BOOST_FILESYSTEM_DECL static substring find_root_directory(path const& p);
-    BOOST_FILESYSTEM_DECL static substring find_relative_path(path const& p);
-    BOOST_FILESYSTEM_DECL static string_type::size_type find_parent_path_size(path const& p);
-    BOOST_FILESYSTEM_DECL static string_type::size_type find_filename_v4_size(path const& p);
-    BOOST_FILESYSTEM_DECL static string_type::size_type find_extension_v4_size(path const& p);
-
-    BOOST_FILESYSTEM_DECL static int lex_compare_v3
-    (
-        path_detail::path_iterator first1, path_detail::path_iterator const& last1,
-        path_detail::path_iterator first2, path_detail::path_iterator const& last2
-    );
-    BOOST_FILESYSTEM_DECL static int lex_compare_v4
-    (
-        path_detail::path_iterator first1, path_detail::path_iterator const& last1,
-        path_detail::path_iterator first2, path_detail::path_iterator const& last2
-    );
-
-    BOOST_FILESYSTEM_DECL static void increment_v3(path_detail::path_iterator& it);
-    BOOST_FILESYSTEM_DECL static void increment_v4(path_detail::path_iterator& it);
-    BOOST_FILESYSTEM_DECL static void decrement_v3(path_detail::path_iterator& it);
-    BOOST_FILESYSTEM_DECL static void decrement_v4(path_detail::path_iterator& it);
+    std::size_t pos;
+    std::size_t size;
 };
 
-} // namespace detail
+} // namespace path_detail
 
 //------------------------------------------------------------------------------------//
 //                                                                                    //
@@ -161,16 +91,12 @@ class path :
 #endif
     >
 {
-    friend class path_detail::path_iterator;
-    friend class path_detail::path_reverse_iterator;
-    friend struct detail::path_algorithms;
-
 public:
     //  value_type is the character type used by the operating system API to
     //  represent paths.
 
-    typedef detail::path_algorithms::value_type value_type;
-    typedef detail::path_algorithms::string_type string_type;
+    typedef path_constants_base::value_type value_type;
+    typedef std::basic_string< value_type > string_type;
     typedef detail::path_traits::codecvt_type codecvt_type;
 
     //  ----- character encoding conversions -----
@@ -301,27 +227,11 @@ private:
         }
     };
 
-    //! Path comparison operation
-    class compare_op
-    {
-    private:
-        path const& m_self;
-
-    public:
-        typedef int result_type;
-
-        explicit compare_op(path const& self) BOOST_NOEXCEPT : m_self(self) {}
-
-        result_type operator() (const value_type* source, const value_type* source_end, const codecvt_type* = NULL) const;
-
-        template< typename OtherChar >
-        result_type operator() (const OtherChar* source, const OtherChar* source_end, const codecvt_type* cvt = NULL) const;
-    };
-
 public:
-    typedef path_detail::path_iterator iterator;
+    class iterator;
+    friend class iterator;
     typedef iterator const_iterator;
-    typedef path_detail::path_reverse_iterator reverse_iterator;
+    class reverse_iterator;
     typedef reverse_iterator const_reverse_iterator;
 
 public:
@@ -345,7 +255,10 @@ public:
         typename Source,
         typename = typename boost::enable_if_c<
             boost::conjunction<
-                detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+                boost::disjunction<
+                    detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+                    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+                >,
                 boost::negation< detail::path_traits::is_native_path_source< typename boost::remove_cv< Source >::type > >
             >::value
         >::type
@@ -355,7 +268,10 @@ public:
     template< typename Source >
     path(Source const& source, typename boost::enable_if_c<
         boost::conjunction<
-            detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+            boost::disjunction<
+                detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+                detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+            >,
             boost::negation< detail::path_traits::is_native_path_source< typename boost::remove_cv< Source >::type > >
         >::value
     >::type* = NULL)
@@ -369,17 +285,23 @@ public:
         typename Source,
         typename = typename boost::enable_if_c<
             boost::conjunction<
-                detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+                boost::disjunction<
+                    detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+                    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+                >,
                 boost::negation< detail::path_traits::is_native_path_source< typename boost::remove_cv< Source >::type > >
             >::value
         >::type
     >
-    explicit path(Source const& source, codecvt_type const& cvt)
+    path(Source const& source, codecvt_type const& cvt)
 #else
     template< typename Source >
-    explicit path(Source const& source, codecvt_type const& cvt, typename boost::enable_if_c<
+    path(Source const& source, codecvt_type const& cvt, typename boost::enable_if_c<
         boost::conjunction<
-            detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+            boost::disjunction<
+                detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+                detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+            >,
             boost::negation< detail::path_traits::is_native_path_source< typename boost::remove_cv< Source >::type > >
         >::value
     >::type* = NULL)
@@ -507,12 +429,6 @@ public:
         }
     }
 
-#if !defined(BOOST_NO_CXX11_NULLPTR)
-    BOOST_DELETED_FUNCTION(path(std::nullptr_t))
-    BOOST_DELETED_FUNCTION(path& operator= (std::nullptr_t))
-#endif
-
-public:
     //  -----  assignments  -----
 
     // We need to explicitly define copy assignment as otherwise it will be implicitly defined as deleted because there is move assignment
@@ -652,7 +568,10 @@ public:
 
     template< typename Source >
     typename boost::enable_if_c<
-        detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
+        boost::disjunction<
+            detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+            detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+        >::value,
         path&
     >::type operator+=(Source const& source)
     {
@@ -791,14 +710,21 @@ public:
 
     template< typename Source >
     BOOST_FORCEINLINE typename boost::enable_if_c<
-        detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
+        boost::disjunction<
+            detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+            detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+        >::value,
         path&
     >::type operator/=(Source const& source)
     {
         return append(source);
     }
 
-    path& append(path const& p);
+    BOOST_FORCEINLINE path& append(path const& p)
+    {
+        BOOST_FILESYSTEM_VERSIONED_SYM(append)(p.m_pathname.data(), p.m_pathname.data() + p.m_pathname.size());
+        return *this;
+    }
 
     template< typename Source >
     BOOST_FORCEINLINE typename boost::enable_if_c<
@@ -823,7 +749,11 @@ public:
         return *this;
     }
 
-    path& append(path const& p, codecvt_type const&);
+    BOOST_FORCEINLINE path& append(path const& p, codecvt_type const&)
+    {
+        BOOST_FILESYSTEM_VERSIONED_SYM(append)(p.m_pathname.data(), p.m_pathname.data() + p.m_pathname.size());
+        return *this;
+    }
 
     template< typename Source >
     BOOST_FORCEINLINE typename boost::enable_if_c<
@@ -848,7 +778,11 @@ public:
         return *this;
     }
 
-    path& append(const value_type* begin, const value_type* end);
+    BOOST_FORCEINLINE path& append(const value_type* begin, const value_type* end)
+    {
+        BOOST_FILESYSTEM_VERSIONED_SYM(append)(begin, end);
+        return *this;
+    }
 
     template< typename InputIterator >
     BOOST_FORCEINLINE typename boost::enable_if_c<
@@ -864,7 +798,11 @@ public:
         return *this;
     }
 
-    path& append(const value_type* begin, const value_type* end, codecvt_type const&);
+    BOOST_FORCEINLINE path& append(const value_type* begin, const value_type* end, codecvt_type const&)
+    {
+        BOOST_FILESYSTEM_VERSIONED_SYM(append)(begin, end);
+        return *this;
+    }
 
     template< typename InputIterator >
     BOOST_FORCEINLINE typename boost::enable_if_c<
@@ -892,12 +830,13 @@ public:
 #else // BOOST_WINDOWS_API
     BOOST_FILESYSTEM_DECL path& make_preferred(); // change slashes to backslashes
 #endif
-    path& remove_filename();
-    BOOST_FILESYSTEM_DECL path& remove_filename_and_trailing_separators();
+    BOOST_FILESYSTEM_DECL path& remove_filename();
     BOOST_FILESYSTEM_DECL path& remove_trailing_separator();
-    BOOST_FILESYSTEM_DECL path& replace_filename(path const& replacement);
-    path& replace_extension(path const& new_extension = path());
-
+    BOOST_FORCEINLINE path& replace_extension(path const& new_extension = path())
+    {
+        BOOST_FILESYSTEM_VERSIONED_SYM(replace_extension)(new_extension);
+        return *this;
+    }
     void swap(path& rhs) BOOST_NOEXCEPT { m_pathname.swap(rhs.m_pathname); }
 
     //  -----  observers  -----
@@ -1003,88 +942,49 @@ public:
 
     //  -----  compare  -----
 
-    int compare(path const& p) const; // generic, lexicographical
-
-    template< typename Source >
-    BOOST_FORCEINLINE typename boost::enable_if_c<
-        detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >::value,
-        int
-    >::type compare(Source const& source) const
+    BOOST_FORCEINLINE int compare(path const& p) const // generic, lexicographical
     {
-        return detail::path_traits::dispatch(source, compare_op(*this));
-    }
-
-    template< typename Source >
-    BOOST_FORCEINLINE typename boost::enable_if_c<
-        boost::conjunction<
-            detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >,
-            boost::negation< detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type > >
-        >::value,
-        int
-    >::type compare(Source const& source) const
-    {
-        return detail::path_traits::dispatch_convertible(source, compare_op(*this));
-    }
-
-    template< typename Source >
-    BOOST_FORCEINLINE typename boost::enable_if_c<
-        detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >::value,
-        int
-    >::type compare(Source const& source, codecvt_type const& cvt) const
-    {
-        return detail::path_traits::dispatch(source, compare_op(*this), &cvt);
-    }
-
-    template< typename Source >
-    BOOST_FORCEINLINE typename boost::enable_if_c<
-        boost::conjunction<
-            detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >,
-            boost::negation< detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type > >
-        >::value,
-        int
-    >::type compare(Source const& source, codecvt_type const& cvt) const
-    {
-        return detail::path_traits::dispatch_convertible(source, compare_op(*this), &cvt);
+        return BOOST_FILESYSTEM_VERSIONED_SYM(compare)(p);
     }
 
     //  -----  decomposition  -----
 
-    path root_path() const { return path(m_pathname.c_str(), m_pathname.c_str() + detail::path_algorithms::find_root_path_size(*this)); }
+    path root_path() const { return path(m_pathname.c_str(), m_pathname.c_str() + find_root_path_size()); }
     // returns 0 or 1 element path even on POSIX, root_name() is non-empty() for network paths
-    path root_name() const { return path(m_pathname.c_str(), m_pathname.c_str() + detail::path_algorithms::find_root_name_size(*this)); }
+    path root_name() const { return path(m_pathname.c_str(), m_pathname.c_str() + find_root_name_size()); }
 
     // returns 0 or 1 element path
     path root_directory() const
     {
-        detail::path_algorithms::substring root_dir = detail::path_algorithms::find_root_directory(*this);
+        path_detail::substring root_dir = find_root_directory();
         const value_type* p = m_pathname.c_str() + root_dir.pos;
         return path(p, p + root_dir.size);
     }
 
     path relative_path() const
     {
-        detail::path_algorithms::substring rel_path = detail::path_algorithms::find_relative_path(*this);
+        path_detail::substring rel_path = find_relative_path();
         const value_type* p = m_pathname.c_str() + rel_path.pos;
         return path(p, p + rel_path.size);
     }
 
-    path parent_path() const { return path(m_pathname.c_str(), m_pathname.c_str() + detail::path_algorithms::find_parent_path_size(*this)); }
+    path parent_path() const { return path(m_pathname.c_str(), m_pathname.c_str() + find_parent_path_size()); }
 
-    path filename() const;  // returns 0 or 1 element path
-    path stem() const;      // returns 0 or 1 element path
-    path extension() const; // returns 0 or 1 element path
+    BOOST_FORCEINLINE path filename() const { return BOOST_FILESYSTEM_VERSIONED_SYM(filename)(); }   // returns 0 or 1 element path
+    BOOST_FORCEINLINE path stem() const { return BOOST_FILESYSTEM_VERSIONED_SYM(stem)(); }           // returns 0 or 1 element path
+    BOOST_FORCEINLINE path extension() const { return BOOST_FILESYSTEM_VERSIONED_SYM(extension)(); } // returns 0 or 1 element path
 
     //  -----  query  -----
 
     bool empty() const BOOST_NOEXCEPT { return m_pathname.empty(); }
     bool filename_is_dot() const;
     bool filename_is_dot_dot() const;
-    bool has_root_path() const { return detail::path_algorithms::find_root_path_size(*this) > 0; }
-    bool has_root_name() const { return detail::path_algorithms::find_root_name_size(*this) > 0; }
-    bool has_root_directory() const { return detail::path_algorithms::find_root_directory(*this).size > 0; }
-    bool has_relative_path() const { return detail::path_algorithms::find_relative_path(*this).size > 0; }
-    bool has_parent_path() const { return detail::path_algorithms::find_parent_path_size(*this) > 0; }
-    bool has_filename() const;
+    bool has_root_path() const { return find_root_path_size() > 0; }
+    bool has_root_name() const { return find_root_name_size() > 0; }
+    bool has_root_directory() const { return find_root_directory().size > 0; }
+    bool has_relative_path() const { return find_relative_path().size > 0; }
+    bool has_parent_path() const { return find_parent_path_size() > 0; }
+    BOOST_FORCEINLINE bool has_filename() const { return BOOST_FILESYSTEM_VERSIONED_SYM(has_filename)(); }
     bool has_stem() const { return !stem().empty(); }
     bool has_extension() const { return !extension().empty(); }
     bool is_relative() const { return !is_absolute(); }
@@ -1100,7 +1000,7 @@ public:
 
     //  -----  lexical operations  -----
 
-    path lexically_normal() const;
+    BOOST_FORCEINLINE path lexically_normal() const { return BOOST_FILESYSTEM_VERSIONED_SYM(lexically_normal)(); }
     BOOST_FILESYSTEM_DECL path lexically_relative(path const& base) const;
     path lexically_proximate(path const& base) const;
 
@@ -1157,6 +1057,53 @@ public:
     //--------------------------------------------------------------------------------------//
     //                            class path private members                                //
     //--------------------------------------------------------------------------------------//
+private:
+    bool has_filename_v3() const { return !m_pathname.empty(); }
+    bool has_filename_v4() const { return find_filename_v4_size() > 0; }
+    BOOST_FILESYSTEM_DECL path filename_v3() const;
+    path filename_v4() const
+    {
+        string_type::size_type filename_size = find_filename_v4_size();
+        string_type::size_type pos = m_pathname.size() - filename_size;
+        const value_type* p = m_pathname.c_str() + pos;
+        return path(p, p + filename_size);
+    }
+    BOOST_FILESYSTEM_DECL path stem_v3() const;
+    BOOST_FILESYSTEM_DECL path stem_v4() const;
+    BOOST_FILESYSTEM_DECL path extension_v3() const;
+    path extension_v4() const
+    {
+        string_type::size_type extension_size = find_extension_v4_size();
+        string_type::size_type pos = m_pathname.size() - extension_size;
+        const value_type* p = m_pathname.c_str() + pos;
+        return path(p, p + extension_size);
+    }
+
+    BOOST_FILESYSTEM_DECL void replace_extension_v3(path const& new_extension);
+    BOOST_FILESYSTEM_DECL void replace_extension_v4(path const& new_extension);
+
+    BOOST_FILESYSTEM_DECL path lexically_normal_v3() const;
+    BOOST_FILESYSTEM_DECL path lexically_normal_v4() const;
+
+    BOOST_FILESYSTEM_DECL int compare_v3(path const& p) const;
+    BOOST_FILESYSTEM_DECL int compare_v4(path const& p) const;
+
+    BOOST_FILESYSTEM_DECL void append_v3(const value_type* b, const value_type* e);
+    BOOST_FILESYSTEM_DECL void append_v4(const value_type* b, const value_type* e);
+
+    //  Returns: If separator is to be appended, m_pathname.size() before append. Otherwise 0.
+    //  Note: An append is never performed if size()==0, so a returned 0 is unambiguous.
+    BOOST_FILESYSTEM_DECL string_type::size_type append_separator_if_needed();
+    BOOST_FILESYSTEM_DECL void erase_redundant_separator(string_type::size_type sep_pos);
+
+    BOOST_FILESYSTEM_DECL string_type::size_type find_root_name_size() const;
+    BOOST_FILESYSTEM_DECL string_type::size_type find_root_path_size() const;
+    BOOST_FILESYSTEM_DECL path_detail::substring find_root_directory() const;
+    BOOST_FILESYSTEM_DECL path_detail::substring find_relative_path() const;
+    BOOST_FILESYSTEM_DECL string_type::size_type find_parent_path_size() const;
+    BOOST_FILESYSTEM_DECL string_type::size_type find_filename_v4_size() const;
+    BOOST_FILESYSTEM_DECL string_type::size_type find_extension_v4_size() const;
+
 private:
     /*
      * m_pathname has the type, encoding, and format required by the native
@@ -1171,6 +1118,8 @@ private:
 };
 
 namespace detail {
+BOOST_FILESYSTEM_DECL int lex_compare_v3(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2);
+BOOST_FILESYSTEM_DECL int lex_compare_v4(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2);
 BOOST_FILESYSTEM_DECL path const& dot_path();
 BOOST_FILESYSTEM_DECL path const& dot_dot_path();
 } // namespace detail
@@ -1179,15 +1128,13 @@ BOOST_FILESYSTEM_DECL path const& dot_dot_path();
 typedef path wpath;
 #endif
 
-namespace path_detail {
-
 //------------------------------------------------------------------------------------//
 //                             class path::iterator                                   //
 //------------------------------------------------------------------------------------//
 
-class path_iterator :
+class path::iterator :
     public boost::iterator_facade<
-        path_iterator,
+        path::iterator,
         const path,
         boost::bidirectional_traversal_tag
     >
@@ -1195,18 +1142,24 @@ class path_iterator :
 private:
     friend class boost::iterator_core_access;
     friend class boost::filesystem::path;
-    friend class path_reverse_iterator;
-    friend struct boost::filesystem::detail::path_algorithms;
+    friend class boost::filesystem::path::reverse_iterator;
+    friend BOOST_FILESYSTEM_DECL int detail::lex_compare_v3(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2);
 
     path const& dereference() const { return m_element; }
 
-    bool equal(path_iterator const& rhs) const BOOST_NOEXCEPT
+    bool equal(iterator const& rhs) const
     {
         return m_path_ptr == rhs.m_path_ptr && m_pos == rhs.m_pos;
     }
 
-    void increment();
-    void decrement();
+    BOOST_FORCEINLINE void increment() { BOOST_FILESYSTEM_VERSIONED_SYM(increment)(); }
+    BOOST_FORCEINLINE void decrement() { BOOST_FILESYSTEM_VERSIONED_SYM(decrement)(); }
+
+private:
+    BOOST_FILESYSTEM_DECL void increment_v3();
+    BOOST_FILESYSTEM_DECL void increment_v4();
+    BOOST_FILESYSTEM_DECL void decrement_v3();
+    BOOST_FILESYSTEM_DECL void decrement_v4();
 
 private:
     // current element
@@ -1218,22 +1171,22 @@ private:
     // position of the last separator in the path.
     // end() iterator is indicated by
     // m_pos == m_path_ptr->m_pathname.size()
-    path::string_type::size_type m_pos;
+    string_type::size_type m_pos;
 };
 
 //------------------------------------------------------------------------------------//
 //                         class path::reverse_iterator                               //
 //------------------------------------------------------------------------------------//
 
-class path_reverse_iterator :
+class path::reverse_iterator :
     public boost::iterator_facade<
-        path_reverse_iterator,
+        path::reverse_iterator,
         const path,
         boost::bidirectional_traversal_tag
     >
 {
 public:
-    explicit path_reverse_iterator(path_iterator itr) :
+    explicit reverse_iterator(iterator itr) :
         m_itr(itr)
     {
         if (itr != itr.m_path_ptr->begin())
@@ -1245,14 +1198,14 @@ private:
     friend class boost::filesystem::path;
 
     path const& dereference() const { return m_element; }
-    bool equal(path_reverse_iterator const& rhs) const BOOST_NOEXCEPT { return m_itr == rhs.m_itr; }
+    bool equal(reverse_iterator const& rhs) const { return m_itr == rhs.m_itr; }
 
     void increment()
     {
         --m_itr;
         if (m_itr != m_itr.m_path_ptr->begin())
         {
-            path_iterator tmp = m_itr;
+            iterator tmp = m_itr;
             m_element = *--tmp;
         }
     }
@@ -1264,163 +1217,53 @@ private:
     }
 
 private:
-    path_iterator m_itr;
+    iterator m_itr;
     path m_element;
 };
 
-//  std::lexicographical_compare would infinitely recurse because path iterators
-//  yield paths, so provide a path aware version
-bool lexicographical_compare(path_iterator first1, path_iterator const& last1, path_iterator first2, path_iterator const& last2);
-
-} // namespace path_detail
-
-using path_detail::lexicographical_compare;
-
 //------------------------------------------------------------------------------------//
 //                                                                                    //
 //                              non-member functions                                  //
 //                                                                                    //
 //------------------------------------------------------------------------------------//
 
-BOOST_FORCEINLINE bool operator==(path const& lhs, path const& rhs)
+//  std::lexicographical_compare would infinitely recurse because path iterators
+//  yield paths, so provide a path aware version
+BOOST_FORCEINLINE bool lexicographical_compare(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
 {
-    return lhs.compare(rhs) == 0;
+    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::lex_compare)(first1, last1, first2, last2) < 0;
 }
 
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator==(path const& lhs, Source const& rhs)
+BOOST_FORCEINLINE bool operator==(path const& lhs, path const& rhs)
 {
     return lhs.compare(rhs) == 0;
 }
 
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator==(Source const& lhs, path const& rhs)
-{
-    return rhs.compare(lhs) == 0;
-}
-
 BOOST_FORCEINLINE bool operator!=(path const& lhs, path const& rhs)
 {
     return lhs.compare(rhs) != 0;
 }
 
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator!=(path const& lhs, Source const& rhs)
-{
-    return lhs.compare(rhs) != 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator!=(Source const& lhs, path const& rhs)
-{
-    return rhs.compare(lhs) != 0;
-}
-
 BOOST_FORCEINLINE bool operator<(path const& lhs, path const& rhs)
 {
     return lhs.compare(rhs) < 0;
 }
 
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator<(path const& lhs, Source const& rhs)
-{
-    return lhs.compare(rhs) < 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator<(Source const& lhs, path const& rhs)
-{
-    return rhs.compare(lhs) > 0;
-}
-
 BOOST_FORCEINLINE bool operator<=(path const& lhs, path const& rhs)
 {
-    return lhs.compare(rhs) <= 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator<=(path const& lhs, Source const& rhs)
-{
-    return lhs.compare(rhs) <= 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator<=(Source const& lhs, path const& rhs)
-{
-    return rhs.compare(lhs) >= 0;
+    return !(rhs < lhs);
 }
 
 BOOST_FORCEINLINE bool operator>(path const& lhs, path const& rhs)
 {
-    return lhs.compare(rhs) > 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator>(path const& lhs, Source const& rhs)
-{
-    return lhs.compare(rhs) > 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator>(Source const& lhs, path const& rhs)
-{
-    return rhs.compare(lhs) < 0;
+    return rhs < lhs;
 }
 
 BOOST_FORCEINLINE bool operator>=(path const& lhs, path const& rhs)
 {
-    return lhs.compare(rhs) >= 0;
+    return !(lhs < rhs);
 }
 
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator>=(path const& lhs, Source const& rhs)
-{
-    return lhs.compare(rhs) >= 0;
-}
-
-template< typename Source >
-BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
-    bool
->::type operator>=(Source const& lhs, path const& rhs)
-{
-    return rhs.compare(lhs) <= 0;
-}
-
-
 // Note: Declared as a template to delay binding to Boost.ContainerHash functions and make the dependency optional
 template< typename T >
 inline typename boost::enable_if_c<
@@ -1451,7 +1294,10 @@ BOOST_FORCEINLINE path operator/(path lhs, path const& rhs)
 
 template< typename Source >
 BOOST_FORCEINLINE typename boost::enable_if_c<
-    detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >::value,
+    boost::disjunction<
+        detail::path_traits::is_path_source< typename boost::remove_cv< Source >::type >,
+        detail::path_traits::is_convertible_to_path_source< typename boost::remove_cv< Source >::type >
+    >::value,
     path
 >::type operator/(path lhs, Source const& rhs)
 {
@@ -1522,41 +1368,6 @@ inline bool is_element_separator(path::value_type c) BOOST_NOEXCEPT
 //                  class path miscellaneous function implementations                 //
 //------------------------------------------------------------------------------------//
 
-namespace detail {
-
-inline bool path_algorithms::has_filename_v3(path const& p)
-{
-    return !p.m_pathname.empty();
-}
-
-inline bool path_algorithms::has_filename_v4(path const& p)
-{
-    return path_algorithms::find_filename_v4_size(p) > 0;
-}
-
-inline path path_algorithms::filename_v4(path const& p)
-{
-    string_type::size_type filename_size = path_algorithms::find_filename_v4_size(p);
-    string_type::size_type pos = p.m_pathname.size() - filename_size;
-    const value_type* ptr = p.m_pathname.c_str() + pos;
-    return path(ptr, ptr + filename_size);
-}
-
-inline path path_algorithms::extension_v4(path const& p)
-{
-    string_type::size_type extension_size = path_algorithms::find_extension_v4_size(p);
-    string_type::size_type pos = p.m_pathname.size() - extension_size;
-    const value_type* ptr = p.m_pathname.c_str() + pos;
-    return path(ptr, ptr + extension_size);
-}
-
-inline void path_algorithms::append_v4(path& left, path const& right)
-{
-    path_algorithms::append_v4(left, right.m_pathname.c_str(), right.m_pathname.c_str() + right.m_pathname.size());
-}
-
-} // namespace detail
-
 // Note: Because of the range constructor in C++23 std::string_view that involves a check for contiguous_range concept,
 //       any non-template function call that requires a check whether the source argument (which may be fs::path)
 //       is convertible to std::string_view must be made after fs::path::iterator is defined. This includes overload
@@ -1564,21 +1375,6 @@ inline void path_algorithms::append_v4(path& left, path const& right)
 //       is not defined and defined, which causes compilation errors with gcc 11 and later.
 //       https://gcc.gnu.org/bugzilla/show_bug.cgi?id=106808
 
-BOOST_FORCEINLINE path::compare_op::result_type path::compare_op::operator() (const value_type* source, const value_type* source_end, const codecvt_type*) const
-{
-    path src;
-    src.m_pathname.assign(source, source_end);
-    return m_self.compare(src);
-}
-
-template< typename OtherChar >
-BOOST_FORCEINLINE path::compare_op::result_type path::compare_op::operator() (const OtherChar* source, const OtherChar* source_end, const codecvt_type* cvt) const
-{
-    path src;
-    detail::path_traits::convert(source, source_end, src.m_pathname, cvt);
-    return m_self.compare(src);
-}
-
 inline path& path::operator=(path const& p)
 {
     return assign(p);
@@ -1635,7 +1431,7 @@ inline bool path::filename_is_dot_dot() const
 #if !defined(BOOST_FILESYSTEM_NO_DEPRECATED)
 
 BOOST_FILESYSTEM_DETAIL_DEPRECATED("Use path::lexically_normal() instead")
-BOOST_FORCEINLINE path& path::normalize()
+inline path& path::normalize()
 {
     path tmp(lexically_normal());
     m_pathname.swap(tmp.m_pathname);
@@ -1644,100 +1440,6 @@ BOOST_FORCEINLINE path& path::normalize()
 
 #endif // !defined(BOOST_FILESYSTEM_NO_DEPRECATED)
 
-// The following functions are defined differently, depending on Boost.Filesystem version in use.
-// To avoid ODR violation, these functions are not defined when the library itself is built.
-// This makes sure they are not compiled when the library is built, and the only version there is
-// is the one in user's code. Users are supposed to consistently use the same Boost.Filesystem version
-// in all their translation units.
-#if !defined(BOOST_FILESYSTEM_SOURCE)
-
-BOOST_FORCEINLINE path& path::append(path const& p)
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::append)(*this, p.m_pathname.data(), p.m_pathname.data() + p.m_pathname.size());
-    return *this;
-}
-
-BOOST_FORCEINLINE path& path::append(path const& p, codecvt_type const&)
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::append)(*this, p.m_pathname.data(), p.m_pathname.data() + p.m_pathname.size());
-    return *this;
-}
-
-BOOST_FORCEINLINE path& path::append(const value_type* begin, const value_type* end)
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::append)(*this, begin, end);
-    return *this;
-}
-
-BOOST_FORCEINLINE path& path::append(const value_type* begin, const value_type* end, codecvt_type const&)
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::append)(*this, begin, end);
-    return *this;
-}
-
-BOOST_FORCEINLINE path& path::remove_filename()
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::remove_filename)(*this);
-    return *this;
-}
-
-BOOST_FORCEINLINE path& path::replace_extension(path const& new_extension)
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::replace_extension)(*this, new_extension);
-    return *this;
-}
-
-BOOST_FORCEINLINE int path::compare(path const& p) const
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::compare)(*this, p);
-}
-
-BOOST_FORCEINLINE path path::filename() const
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::filename)(*this);
-}
-
-BOOST_FORCEINLINE path path::stem() const
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::stem)(*this);
-}
-
-BOOST_FORCEINLINE path path::extension() const
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::extension)(*this);
-}
-
-BOOST_FORCEINLINE bool path::has_filename() const
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::has_filename)(*this);
-}
-
-BOOST_FORCEINLINE path path::lexically_normal() const
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::lexically_normal)(*this);
-}
-
-namespace path_detail {
-
-BOOST_FORCEINLINE void path_iterator::increment()
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::increment)(*this);
-}
-
-BOOST_FORCEINLINE void path_iterator::decrement()
-{
-    BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::decrement)(*this);
-}
-
-BOOST_FORCEINLINE bool lexicographical_compare(path_iterator first1, path_iterator const& last1, path_iterator first2, path_iterator const& last2)
-{
-    return BOOST_FILESYSTEM_VERSIONED_SYM(detail::path_algorithms::lex_compare)(first1, last1, first2, last2) < 0;
-}
-
-} // namespace path_detail
-
-#endif // !defined(BOOST_FILESYSTEM_SOURCE)
-
 //--------------------------------------------------------------------------------------//
 //                     class path member template specializations                       //
 //--------------------------------------------------------------------------------------//
diff --git a/boost_1_82_0/libs/filesystem/CMakeLists.txt b/boost_1_82_0/libs/filesystem/CMakeLists.txt
index 0db21d7cf9..b2a3d7dd5b 100644
--- a/boost_1_82_0/libs/filesystem/CMakeLists.txt
+++ b/boost_1_82_0/libs/filesystem/CMakeLists.txt
@@ -73,31 +73,6 @@ endif()
 add_library(boost_filesystem ${BOOST_FILESYSTEM_SOURCES})
 add_library(Boost::filesystem ALIAS boost_filesystem)
 
-get_target_property(BOOST_FILESYSTEM_TARGET_TYPE boost_filesystem TYPE)
-if(BOOST_FILESYSTEM_TARGET_TYPE STREQUAL "SHARED_LIBRARY")
-    set(CMAKE_REQUIRED_LIBRARIES "-Wl,--no-undefined")
-    check_cxx_source_compiles("#include <${CMAKE_CURRENT_SOURCE_DIR}/config/has_linkflag_no_undefined.cpp>" BOOST_FILESYSTEM_HAS_LINKFLAG_NO_UNDEFINED)
-    unset(CMAKE_REQUIRED_LIBRARIES)
-    if(NOT BOOST_FILESYSTEM_HAS_LINKFLAG_NO_UNDEFINED)
-        set(CMAKE_REQUIRED_LIBRARIES "-Wl,-undefined,error")
-        check_cxx_source_compiles("#include <${CMAKE_CURRENT_SOURCE_DIR}/config/has_linkflag_no_undefined.cpp>" BOOST_FILESYSTEM_HAS_LINKFLAG_UNDEFINED_ERROR)
-        unset(CMAKE_REQUIRED_LIBRARIES)
-    endif()
-    if(BOOST_FILESYSTEM_HAS_LINKFLAG_NO_UNDEFINED)
-        if(NOT CMAKE_VERSION VERSION_LESS 3.13)
-            target_link_options(boost_filesystem PRIVATE "-Wl,--no-undefined")
-        else()
-            target_link_libraries(boost_filesystem PRIVATE "-Wl,--no-undefined")
-        endif()
-    elseif(BOOST_FILESYSTEM_HAS_LINKFLAG_UNDEFINED_ERROR)
-        if(NOT CMAKE_VERSION VERSION_LESS 3.13)
-            target_link_options(boost_filesystem PRIVATE "-Wl,-undefined,error")
-        else()
-            target_link_libraries(boost_filesystem PRIVATE "-Wl,-undefined,error")
-        endif()
-    endif()
-endif()
-
 target_include_directories(boost_filesystem PUBLIC include)
 target_include_directories(boost_filesystem PRIVATE src)
 
@@ -132,16 +107,6 @@ if(WIN32 OR CYGWIN)
     )
 endif()
 
-if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" AND
-    (CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 12 OR CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 12) AND
-    CMAKE_CXX_COMPILER_VERSION VERSION_LESS 13)
-    # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105329
-    # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105651
-    target_compile_options(boost_filesystem PRIVATE
-        -Wno-restrict
-    )
-endif()
-
 if(BOOST_FILESYSTEM_NO_DEPRECATED)
     target_compile_definitions(boost_filesystem PUBLIC BOOST_FILESYSTEM_NO_DEPRECATED)
 endif()
diff --git a/boost_1_82_0/libs/filesystem/build/Jamfile.v2 b/boost_1_82_0/libs/filesystem/build/Jamfile.v2
index 13c540da1a..afc8d374fb 100644
--- a/boost_1_82_0/libs/filesystem/build/Jamfile.v2
+++ b/boost_1_82_0/libs/filesystem/build/Jamfile.v2
@@ -101,27 +101,6 @@ rule check-cxx20-atomic-ref ( properties * )
     return $(result) ;
 }
 
-# The rule checks if the linker supports requiring no unresolved symbols
-rule check-linkflag-no-undefined ( properties * )
-{
-    local result ;
-
-    if <link>shared in $(properties)
-    {
-        if [ configure.builds ../config//has_linkflag_no_undefined : $(properties) : "has -Wl,--no-undefined" ]
-        {
-            result = <linkflags>"-Wl,--no-undefined" ;
-        }
-        else if [ configure.builds ../config//has_linkflag_undefined_error : $(properties) : "has -Wl,-undefined,error" ]
-        {
-            result = <linkflags>"-Wl,-undefined,error" ;
-        }
-    }
-
-    #ECHO Result: $(result) ;
-    return $(result) ;
-}
-
 project boost/filesystem
     : requirements
       <host-os>hpux,<toolset>gcc:<define>_INCLUDE_STDC__SOURCE_199901
@@ -138,8 +117,6 @@ project boost/filesystem
       <conditional>@check-statx
       <conditional>@select-windows-crypto-api
       <conditional>@check-cxx20-atomic-ref
-      # Make sure no undefined references are left from the library
-      <conditional>@check-linkflag-no-undefined
       <target-os>windows:<define>_SCL_SECURE_NO_WARNINGS
       <target-os>windows:<define>_SCL_SECURE_NO_DEPRECATE
       <target-os>windows:<define>_CRT_SECURE_NO_WARNINGS
@@ -150,11 +127,6 @@ project boost/filesystem
       <target-os>cygwin:<define>BOOST_USE_WINDOWS_H
       <target-os>cygwin:<define>WIN32_LEAN_AND_MEAN
       <target-os>cygwin:<define>NOMINMAX
-
-      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105329
-      # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105651
-      <toolset>gcc-12:<cxxflags>"-Wno-restrict"
-
     : source-location ../src
     : usage-requirements # pass these requirement to dependents (i.e. users)
       <link>shared:<define>BOOST_FILESYSTEM_DYN_LINK=1
diff --git a/boost_1_82_0/libs/filesystem/config/Jamfile.v2 b/boost_1_82_0/libs/filesystem/config/Jamfile.v2
index aae2af5aad..b34d3aafe3 100644
--- a/boost_1_82_0/libs/filesystem/config/Jamfile.v2
+++ b/boost_1_82_0/libs/filesystem/config/Jamfile.v2
@@ -39,8 +39,3 @@ exe has_bcrypt : has_bcrypt.cpp : <include>../src <library>bcrypt ;
 explicit has_bcrypt ;
 obj is_windows_ce : is_windows_ce.cpp ;
 explicit is_windows_ce ;
-
-lib has_linkflag_no_undefined : has_linkflag_no_undefined.cpp : <link>shared <linkflags>"-Wl,--no-undefined" ;
-explicit has_linkflag_no_undefined ;
-lib has_linkflag_undefined_error : has_linkflag_no_undefined.cpp : <link>shared <linkflags>"-Wl,-undefined,error" ;
-explicit has_linkflag_undefined_error ;
diff --git a/boost_1_82_0/libs/filesystem/config/has_linkflag_no_undefined.cpp b/boost_1_82_0/libs/filesystem/config/has_linkflag_no_undefined.cpp
deleted file mode 100644
index 94960fc249..0000000000
--- a/boost_1_82_0/libs/filesystem/config/has_linkflag_no_undefined.cpp
+++ /dev/null
@@ -1,18 +0,0 @@
-//  Copyright 2023 Andrey Semashev
-
-//  Distributed under the Boost Software License, Version 1.0.
-//  See http://www.boost.org/LICENSE_1_0.txt
-
-//  See library home page at http://www.boost.org/libs/filesystem
-
-#if defined(_MSC_VER)
-// MSVC's link.exe does not support -Wl,... flags, but doesn't fail the linking.
-// The linker may be used by different compilers, not only MSVC.
-// Luckily, those compilers all pretend to be MSVC.
-#error "MSVC and compatible compilers don't support -Wl,... flags"
-#endif
-
-int main()
-{
-    return 0;
-}
diff --git a/boost_1_82_0/libs/filesystem/doc/release_history.html b/boost_1_82_0/libs/filesystem/doc/release_history.html
index 08a51270ca..74f0d06724 100644
--- a/boost_1_82_0/libs/filesystem/doc/release_history.html
+++ b/boost_1_82_0/libs/filesystem/doc/release_history.html
@@ -39,17 +39,6 @@
     </td>
 </table>
 
-<h2>1.82.0</h2>
-<ul>
-  <li>Due to changes in Boost.System and some other libraries used in Boost.Filesystem, the support for C++03 is deprecated. C++11 will become the minimum starting with Boost.Filesystem 1.84.</li>
-  <li>Fixed compilation errors that could have been caused by <code>path</code> conversion constructors being too permissive on the accepted arguments. (<a href="https://github.com/boostorg/filesystem/issues/273">#273</a>)</li>
-  <li><b>v4:</b> <code>path::remove_filename</code> now presesrves the trailing directory separator. (<a href="https://github.com/boostorg/filesystem/issues/271">#271</a>)</li>
-  <li>Added <code>path::remove_filename_and_trailing_separators</li>, which removes the filename and directory separators preceding it from the path. This behavior is similar to <code>path::remove_filename</code> in Filesystem <b>v3</b>, but is also usable in <b>v4</b>.
-  <li>Added <code>path::replace_filename</code>, which replaces filename in a path.</li>
-  <li>Updated implementation of the library version selection to avoid ODR violations. (<a href="https://github.com/boostorg/filesystem/issues/279">#279</a>)</li>
-  <li>On Windows, added a workaround for querying file attributes for files in SMBv1 shares. Previously, directories in SMBv1 shares could have been reported as regular files. This does not affect SMBv2 or later. (<a href="https://github.com/boostorg/filesystem/issues/282">#282</a>)</li>
-</ul>
-
 <h2>1.81.0</h2>
 <ul>
   <li><b>Deprecated:</b> <code>path</code> construction, assignment and appending from containers of characters, such as <code>std::vector&lt;char&gt;</code> or <code>std::list&lt;wchar_t&gt;</code>, is deprecated in <b>v3</b> and removed in <b>v4</b>. Please use string types or iterators instead.</li>
diff --git a/boost_1_82_0/libs/filesystem/doc/tutorial.html b/boost_1_82_0/libs/filesystem/doc/tutorial.html
index e6a8689c17..498b05d45d 100644
--- a/boost_1_82_0/libs/filesystem/doc/tutorial.html
+++ b/boost_1_82_0/libs/filesystem/doc/tutorial.html
@@ -72,24 +72,30 @@ ready to build.</p>
 <a href="http://www.boost.org/more/getting_started/index.html">Boost Getting
 Started</a> docs.</p>
 
-<p>This tutorial assumes you have bootstrapped Boost.Build and compiled Boost.Filesystem
-as described in the Getting Started article. The <code>b2</code> executable is expected
-to be available in <code>PATH</code>.</p>
+<p>This tutorial assumes you are going to compile and test the examples using
+the provided scripts. That's highly recommended.</p>
 
 <blockquote>
 
+<p><b>If you are planning to compile and test the examples but not use the
+scripts, make sure your build setup knows where to
+locate or build the Boost library binaries.</b></p>
+
 </blockquote>
 <p>Fire up your command line interpreter, and type the following commands:</p>
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td>
-      <pre>$ cd <i><b>boost-root</b></i>/libs/filesystem/example
+      <pre>$ cd <i><b>boost-root</b></i>/libs/filesystem/example/test
+
+$ ./setup.sh
+Copying example programs...
 
-$ b2 tutorial
+$ ./build.sh
 Compiling example programs...
 
 $ ./tut1
@@ -106,9 +112,12 @@ Usage: tut1 path</pre>
     </tr>
     <tr>
     <td>
-      <pre>&gt;cd <i><b>boost-root</b></i>\libs\filesystem\example
+      <pre>&gt;cd <i><b>boost-root</b></i>\libs\filesystem\example\test
 
-&gt;b2.exe tutorial
+&gt;setup
+Copying example programs...
+
+&gt;build
 Compiling example programs...
 
 &gt;tut1
@@ -118,10 +127,11 @@ Usage: tut1 path</pre>
   </table>
 
 <p>If the <code>tut1</code> command outputs &quot;<code>Usage: tut1 path</code>&quot;, all
-is well. The tutorial example programs are available in
-<code><i><b>boost-root</b></i>/libs/filesystem/example</code>. Should you modify
-and experiment with them as the tutorial progresses, just invoke <code>b2 tutorial</code> again
-to rebuild.</p>
+is well. A set of tutorial example programs has been copied (by <code>setup</code>) to
+<i><b><code>boost-root</code></b></i><code>/libs/filesystem/example/test</code>
+and then built. You are encouraged to modify and experiment with them as the
+tutorial progresses. Just invoke the <code>build</code> script again to rebuild,
+or invoke <code>b2</code> directly.</p>
 
 <p>If something didn't work right, here are some troubleshooting suggestions:</p>
 
@@ -131,7 +141,7 @@ to rebuild.</p>
     <a href="http://www.boost.org/more/getting_started/windows.html">Boost
     Getting Started</a>.<br>
 &nbsp;</li>
-    <li>Look at Boost bootstrap output to try to spot an indication of the
+    <li>Look at <code>b2.log</code> to try to spot an indication of the
     problem.</li>
   </ul>
 
@@ -179,7 +189,7 @@ results look like on two different operating systems:</p>
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td valign="top">
@@ -220,7 +230,7 @@ from the above if changes have been made to <code>tut1.cpp</code>.</p>
   <table border="1" cellpadding="5" cellspacing="0"
     style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td valign="top">
@@ -256,7 +266,7 @@ exception is thrown. See <a href="#Error-reporting">Error reporting</a> to learn
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td>
@@ -343,7 +353,7 @@ int main(int argc, char* argv[])
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td valign="top">
@@ -387,7 +397,7 @@ we will see how to iterate over directories.</p>
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td valign="top">
@@ -440,7 +450,8 @@ acts as the end iterator.</p>
 <p>The value type of <code>directory_iterator</code> is <code>
 <a href="reference.html#directory_entry">directory_entry</a></code>. A <code>
 directory_entry</code> object contains <code>path</code> and <code><a href="reference.html#file_status">file_status</a></code>
-information. A <code>directory_entry</code> object
+information.&nbsp; A <code>
+directory_entry</code> object
 can be used directly, but can also be passed to <code>path</code> arguments in function calls.</p>
 
 <p>The other need is increased robustness in the face of the many kinds of
@@ -505,7 +516,7 @@ of the test cases that caused exceptions on Linux and Windows:</p>
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td valign="top">
@@ -692,8 +703,8 @@ for (auto&amp;&amp; x : v)
     <a href="reference.html#path-filename">filename()</a></code> is one of
     several class <code>path</code> decomposition functions. It extracts the
     filename portion
-    from a path (i.e. <code>&quot;index.html&quot;</code>
-    from <code>&quot;/home/beman/boost/trunk/index.html&quot;</code>). These decomposition functions are
+    from a path (<font face="Courier New">i.e. </font><code>&quot;index.html&quot;</code><font face="Courier New">
+    from </font><code>&quot;/home/beman/boost/trunk/index.html&quot;</code>). These decomposition functions are
     more fully explored in the <a href="#Class path-iterators-etc">Path iterators, observers,
     composition, decomposition and query</a> portion of this tutorial.</p>
     <p>The above was written as two lines of code for clarity. It could have
@@ -705,41 +716,11 @@ for (auto&amp;&amp; x : v)
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td>
-      <pre>$ ./tut4 ~/boost/develop
-"/home/beman/boost/develop" is a directory containing:
-    ".git"
-    ".gitattributes"
-    ".gitignore"
-    ".gitmodules"
-    ".travis.yml"
-    "INSTALL"
-    "Jamroot"
-    "LICENSE_1_0.txt"
-    "bin.v2"
-    "boost"
-    "boost-build.jam"
-    "boost.css"
-    "boost.png"
-    "boostcpp.jam"
-    "boostcpp.py"
-    "bootstrap.bat"
-    "bootstrap.sh"
-    "doc"
-    "index.htm"
-    "index.html"
-    "libs"
-    "more"
-    "project-config.jam"
-    "project-config.jam.1"
-    "project-config.jam.2"
-    "rst.css"
-    "stage"
-    "status"
-    "tools"</pre>
+      <pre>$ ./tut4  v</pre>
       </td>
     </tr>
   </table>
@@ -752,37 +733,37 @@ for (auto&amp;&amp; x : v)
     </tr>
     <tr>
       <td>
-      <pre>&gt;tut4 \boost\develop
-"\boost\develop" is a directory containing:
-    ".git"
-    ".gitattributes"
-    ".gitignore"
-    ".gitmodules"
-    ".travis.yml"
-    "INSTALL"
-    "Jamroot"
-    "LICENSE_1_0.txt"
-    "bin.v2"
-    "boost"
-    "boost-build.jam"
-    "boost.css"
-    "boost.png"
-    "boostcpp.jam"
-    "boostcpp.py"
-    "bootstrap.bat"
-    "bootstrap.sh"
-    "doc"
-    "index.htm"
-    "index.html"
-    "libs"
-    "more"
-    "project-config.jam"
-    "project-config.jam.1"
-    "project-config.jam.2"
-    "rst.css"
-    "stage"
-    "status"
-    "tools"</pre>
+      <pre>$ ./tut4 ~/boost/develop
+"/home/beman/boost/develop" is a directory containing:
+    .git
+    .gitattributes
+    .gitignore
+    .gitmodules
+    .travis.yml
+    INSTALL
+    Jamroot
+    LICENSE_1_0.txt
+    bin.v2
+    boost
+    boost-build.jam
+    boost.css
+    boost.png
+    boostcpp.jam
+    boostcpp.py
+    bootstrap.bat
+    bootstrap.sh
+    doc
+    index.htm
+    index.html
+    libs
+    more
+    project-config.jam
+    project-config.jam.1
+    project-config.jam.2
+    rst.css
+    stage
+    status
+    tools</pre>
       </td>
     </tr>
   </table>
@@ -883,7 +864,7 @@ int main()
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td valign="top">
@@ -921,7 +902,7 @@ smile&#9786;</pre>
 <p>The exact appearance of the smiling face will depend on the font,
 font size, and other settings for your command line window. The above tests were
 run with out-of-the-box Ubuntu 14.04 and Windows 7, US Edition. If you don't get
-the above results, take a look at the <code><i><b>boost-root</b></i>/libs/filesystem/example</code>
+the above results, take a look at the <code><i>boost-root</i>/libs/filesystem/example/test</code>
 directory with your system's GUI file browser, such as Linux Nautilus, Mac OS X
 Finder, or Windows Explorer. These tend to be more comfortable with
 international character sets than command line interpreters.</p>
@@ -981,7 +962,9 @@ for how that plays out.</p>
 
 <p>The <code><a href="../example/path_info.cpp">path_info.cpp</a></code> program is handy for learning how class <code>path</code>
 iterators,
-observers, composition, decomposition, and query functions work on your system.</p>
+observers, composition, decomposition, and query functions work on your system.
+It is one of the programs built by the <code>build.sh</code> and <code>build.bat</code>
+scripts:</p>
 
 
 <table border="1" cellpadding="3" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
@@ -1070,7 +1053,7 @@ as we go along. Here is the invocation we will talk about in detail:</p>
 
   <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" bgcolor="#D7EEFF">
     <tr>
-      <td align="center"><i><b>Ubuntu Linux</b></i></td>
+      <td align="center"><i><b>Ubuntu Linux </b></i></td>
     </tr>
     <tr>
       <td>
@@ -1179,7 +1162,7 @@ has_extension()------: true</pre>
 <p>We will go through the above code in detail to gain a better
 understanding of what is going on.</p>
 
-<p>A common need is to compose a path from its constituent
+<p dir="ltr">A common need is to compose a path from its constituent
 directories. Class <code>path</code> uses <code>/</code> and <code>/=</code> operators to
 append elements. That's a reminder
 that these operations append the operating system's preferred directory
@@ -1187,7 +1170,7 @@ separator if needed. The preferred
 directory separator is a slash on POSIX-like systems, and a backslash on
 Windows-like systems.</p>
 
-<p>That's what this code does before displaying the resulting <code>
+<p dir="ltr">That&#39;s what this code does before displaying the resulting <code>
 path p</code> using the <code>class path</code> stream inserter: </p>
 
 
@@ -1208,7 +1191,7 @@ path p</code> using the <code>class path</code> stream inserter: </p>
 
 <p>One abstraction for thinking about a path is as a sequence of elements, where
 the elements are directory and file names. To support this abstraction, class
-<code>path</code> provides iterators and also <code>begin()</code>
+<code>path</code> provides STL-like&nbsp; iterators and also <code>begin()</code>
 and <code>end()</code> functions.</p>
 
 <p>Here is the code that produced the list of elements in the above output listing:</p>
diff --git a/boost_1_82_0/libs/filesystem/doc/v4.html b/boost_1_82_0/libs/filesystem/doc/v4.html
index 4bd627a60a..38f10a8428 100644
--- a/boost_1_82_0/libs/filesystem/doc/v4.html
+++ b/boost_1_82_0/libs/filesystem/doc/v4.html
@@ -53,7 +53,6 @@ It removes the features that were <a href="deprecated.html">deprecated</a> in Ve
   <li><a href="reference.html#lexically_normal"><code>path::lexically_normal</code></a> no longer produces a trailing dot (".") element and omits a directory separator after a trailing dot-dot ("..") element in the normalized paths.</li>
   <li><a href="reference.html#path-appends"><code>path</code> appends</a> consider root name and root directory of the appended path. If the appended path is absolute, or root name is present and differs from the source path, the resulting path is equivalent to the appended path. If root directory is present, the result is the root directory and relative path rebased on top of the root name of the source path. Otherwise, the behavior is similar to v3. This behavior is similar to C++17 std::filesystem.</li>
   <li><code>path</code> no longer supports construction, assignment or appending from containers of characters. Use string types or iterators as the source for these opereations instead.</li>
-  <li><a href="reference.html#path-remove_filename"><code>path::remove_filename</code></a> preserves the trailing directory separator, so that <code>path::has_filename</code> returns <code>false</code> after a successful call to <code>path::remove_filename</code>.</li>
 </ul>
 
 <hr>
diff --git a/boost_1_82_0/libs/filesystem/example/Jamfile.v2 b/boost_1_82_0/libs/filesystem/example/Jamfile.v2
index f047cf3df2..9d7c64f53f 100644
--- a/boost_1_82_0/libs/filesystem/example/Jamfile.v2
+++ b/boost_1_82_0/libs/filesystem/example/Jamfile.v2
@@ -22,15 +22,4 @@ exe tut5 : tut5.cpp ;
 exe path_info : path_info.cpp : <cxxstd>11 ;
 exe file_status : file_status.cpp ;
 exe file_size : file_size.cpp ;
-exe directory_symlink_parent_resolution : directory_symlink_parent_resolution.cpp ;
-exe simple_ls : simple_ls.cpp ;
-
-install tut1-copy : tut1 : <location>. ;
-install tut2-copy : tut2 : <location>. ;
-install tut3-copy : tut3 : <location>. ;
-install tut4-copy : tut4 : <location>. ;
-install tut5-copy : tut5 : <location>. ;
-install path_info-copy : path_info : <location>. ;
-
-alias tutorial : tut1-copy tut2-copy tut3-copy tut4-copy tut5-copy path_info-copy ;
-explicit tut1-copy tut2-copy tut3-copy tut4-copy tut5-copy path_info-copy tutorial ;
+exe directory_symlink_parent_resolution : directory_symlink_parent_resolution.cpp ;
\ No newline at end of file
diff --git a/boost_1_82_0/libs/filesystem/src/directory.cpp b/boost_1_82_0/libs/filesystem/src/directory.cpp
index 7ec7d12a18..7eeda2613c 100644
--- a/boost_1_82_0/libs/filesystem/src/directory.cpp
+++ b/boost_1_82_0/libs/filesystem/src/directory.cpp
@@ -1109,18 +1109,7 @@ void directory_iterator_construct(directory_iterator& it, path const& p, unsigne
                 && (filename_str[1] == static_cast< path::string_type::value_type >('\0') ||
                     (filename_str[1] == path::dot && filename_str[2] == static_cast< path::string_type::value_type >('\0')))))
             {
-                path full_path(p);
-                path_algorithms::append_v4(full_path, filename);
-                imp->dir_entry.assign
-                (
-#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)
-                    static_cast< path&& >(full_path),
-#else
-                    full_path,
-#endif
-                    file_stat,
-                    symlink_file_stat
-                );
+                imp->dir_entry.assign(p / filename, file_stat, symlink_file_stat);
                 it.m_imp.swap(imp);
                 return;
             }
diff --git a/boost_1_82_0/libs/filesystem/src/operations.cpp b/boost_1_82_0/libs/filesystem/src/operations.cpp
index 3dae46b633..b1c14d62e5 100644
--- a/boost_1_82_0/libs/filesystem/src/operations.cpp
+++ b/boost_1_82_0/libs/filesystem/src/operations.cpp
@@ -1116,7 +1116,7 @@ uintmax_t remove_all_impl
                 count += fs::detail::remove_all_impl
                 (
 #if defined(BOOST_FILESYSTEM_HAS_FDOPENDIR_NOFOLLOW) && defined(BOOST_FILESYSTEM_HAS_POSIX_AT_APIS)
-                    path_algorithms::filename_v4(itr->path()),
+                    itr->path().filename(),
 #else
                     itr->path(),
 #endif
@@ -1530,7 +1530,7 @@ inline bool is_reparse_point_a_symlink(path const& p)
 {
     handle_wrapper h(create_file_handle(
         p,
-        FILE_READ_ATTRIBUTES | FILE_READ_EA,
+        FILE_READ_ATTRIBUTES,
         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
         NULL,
         OPEN_EXISTING,
@@ -1650,13 +1650,9 @@ fs::file_status status_by_handle(HANDLE h, path const& p, error_code* ec)
 //! symlink_status() implementation
 fs::file_status symlink_status_impl(path const& p, error_code* ec)
 {
-    // Normally, we only need FILE_READ_ATTRIBUTES access mode. But SMBv1 reports incorrect
-    // file attributes in GetFileInformationByHandleEx in this case (e.g. it reports FILE_ATTRIBUTE_NORMAL
-    // for a directory in a SMBv1 share), so we add FILE_READ_EA as a workaround.
-    // https://github.com/boostorg/filesystem/issues/282
     handle_wrapper h(create_file_handle(
         p.c_str(),
-        FILE_READ_ATTRIBUTES | FILE_READ_EA,
+        FILE_READ_ATTRIBUTES, // dwDesiredAccess; attributes only
         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
         NULL, // lpSecurityAttributes
         OPEN_EXISTING,
@@ -1700,7 +1696,7 @@ fs::file_status status_impl(path const& p, error_code* ec)
         // Resolve the symlink
         handle_wrapper h(create_file_handle(
             p.c_str(),
-            FILE_READ_ATTRIBUTES | FILE_READ_EA, // see the comment in symlink_status_impl re. access mode
+            FILE_READ_ATTRIBUTES, // dwDesiredAccess; attributes only
             FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
             NULL, // lpSecurityAttributes
             OPEN_EXISTING,
@@ -1914,7 +1910,7 @@ inline bool remove_nt6_impl(path const& p, remove_impl_type impl, error_code* ec
 {
     handle_wrapper h(create_file_handle(
         p,
-        DELETE | FILE_READ_ATTRIBUTES | FILE_READ_EA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA,
+        DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
         NULL,
         OPEN_EXISTING,
@@ -2011,9 +2007,9 @@ uintmax_t remove_all_nt6_by_handle(HANDLE h, path const& p, error_code* ec)
                 (
                     hh.handle,
                     h,
-                    path_algorithms::filename_v4(nested_path),
+                    nested_path.filename(),
                     0u, // FileAttributes
-                    FILE_LIST_DIRECTORY | DELETE | FILE_READ_ATTRIBUTES | FILE_READ_EA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | SYNCHRONIZE,
+                    FILE_LIST_DIRECTORY | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     FILE_OPEN,
                     FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT | FILE_OPEN_REPARSE_POINT
@@ -2039,7 +2035,7 @@ uintmax_t remove_all_nt6_by_handle(HANDLE h, path const& p, error_code* ec)
             {
                 hh.handle = create_file_handle(
                     nested_path,
-                    FILE_LIST_DIRECTORY | DELETE | FILE_READ_ATTRIBUTES | FILE_READ_EA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | SYNCHRONIZE,
+                    FILE_LIST_DIRECTORY | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     NULL,
                     OPEN_EXISTING,
@@ -2156,7 +2152,7 @@ inline uintmax_t remove_all_impl(path const& p, error_code* ec)
     {
         handle_wrapper h(create_file_handle(
             p,
-            FILE_LIST_DIRECTORY | DELETE | FILE_READ_ATTRIBUTES | FILE_READ_EA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | SYNCHRONIZE,
+            FILE_LIST_DIRECTORY | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
             FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
             NULL,
             OPEN_EXISTING,
@@ -2397,12 +2393,12 @@ path absolute(path const& p, path const& base, system::error_code* ec)
     else
     {
         res.concat(abs_base.root_directory());
-        path_algorithms::append_v4(res, abs_base.relative_path());
+        res /= abs_base.relative_path();
     }
 
     path p_relative_path(p.relative_path());
     if (!p_relative_path.empty())
-        path_algorithms::append_v4(res, p_relative_path);
+        res /= p_relative_path;
 
     return res;
 }
@@ -2449,14 +2445,14 @@ path canonical(path const& p, path const& base, system::error_code* ec)
     path result;
     while (true)
     {
-        for (path::iterator itr(source.begin()), end(source.end()); itr != end; path_algorithms::increment_v4(itr))
+        for (path::iterator itr(source.begin()), end(source.end()); itr != end; ++itr)
         {
-            if (path_algorithms::compare_v4(*itr, dot_p) == 0)
+            if (*itr == dot_p)
                 continue;
-            if (path_algorithms::compare_v4(*itr, dot_dot_p) == 0)
+            if (*itr == dot_dot_p)
             {
-                if (path_algorithms::compare_v4(result, root) != 0)
-                    result.remove_filename_and_trailing_separators();
+                if (result != root)
+                    result.remove_filename();
                 continue;
             }
 
@@ -2471,7 +2467,7 @@ path canonical(path const& p, path const& base, system::error_code* ec)
                 continue;
             }
 
-            path_algorithms::append_v4(result, *itr);
+            result /= *itr;
 
             // If we don't have an absolute path yet then don't check symlink status.
             // This avoids checking "C:" which is "the current directory on drive C"
@@ -2496,14 +2492,14 @@ path canonical(path const& p, path const& base, system::error_code* ec)
                 path link(detail::read_symlink(result, ec));
                 if (ec && *ec)
                     goto return_empty_path;
-                result.remove_filename_and_trailing_separators();
+                result.remove_filename();
 
                 if (link.is_absolute())
                 {
-                    for (path_algorithms::increment_v4(itr); itr != end; path_algorithms::increment_v4(itr))
+                    for (++itr; itr != end; ++itr)
                     {
-                        if (path_algorithms::compare_v4(*itr, dot_p) != 0)
-                            path_algorithms::append_v4(link, *itr);
+                        if (*itr != dot_p)
+                            link /= *itr;
                     }
                     source = link;
                     root = source.root_path();
@@ -2511,15 +2507,15 @@ path canonical(path const& p, path const& base, system::error_code* ec)
                 else // link is relative
                 {
                     link.remove_trailing_separator();
-                    if (path_algorithms::compare_v4(link, dot_p) == 0)
+                    if (link == dot_p)
                         continue;
 
                     path new_source(result);
-                    path_algorithms::append_v4(new_source, link);
-                    for (path_algorithms::increment_v4(itr); itr != end; path_algorithms::increment_v4(itr))
+                    new_source /= link;
+                    for (++itr; itr != end; ++itr)
                     {
-                        if (path_algorithms::compare_v4(*itr, dot_p) != 0)
-                            path_algorithms::append_v4(new_source, *itr);
+                        if (*itr != dot_p)
+                            new_source /= *itr;
                     }
                     source = new_source;
                 }
@@ -2615,10 +2611,10 @@ void copy(path const& from, path const& to, unsigned int options, system::error_
                 relative_from = detail::relative(abs_from, abs_to, ec);
                 if (ec && *ec)
                     return;
-                if (path_algorithms::compare_v4(relative_from, dot_path()) != 0)
-                    path_algorithms::append_v4(relative_from, path_algorithms::filename_v4(from));
+                if (relative_from != dot_path())
+                    relative_from /= from.filename();
                 else
-                    relative_from = path_algorithms::filename_v4(from);
+                    relative_from = from.filename();
                 pfrom = &relative_from;
             }
             detail::create_symlink(*pfrom, to, ec);
@@ -2654,11 +2650,7 @@ void copy(path const& from, path const& to, unsigned int options, system::error_
         }
 
         if (is_directory(to_stat))
-        {
-            path target(to);
-            path_algorithms::append_v4(target, path_algorithms::filename_v4(from));
-            detail::copy_file(from, target, options, ec);
-        }
+            detail::copy_file(from, to / from.filename(), options, ec);
         else
             detail::copy_file(from, to, options, ec);
     }
@@ -2713,12 +2705,8 @@ void copy(path const& from, path const& to, unsigned int options, system::error_
             while (itr != end_dit)
             {
                 path const& p = itr->path();
-                {
-                    path target(to);
-                    path_algorithms::append_v4(target, path_algorithms::filename_v4(p));
-                    // Set _detail_recursing flag so that we don't recurse more than for one level deeper into the directory if options are copy_options::none
-                    detail::copy(p, target, options | static_cast< unsigned int >(copy_options::_detail_recursing), ec);
-                }
+                // Set _detail_recursing flag so that we don't recurse more than for one level deeper into the directory if options are copy_options::none
+                detail::copy(p, to / p.filename(), options | static_cast< unsigned int >(copy_options::_detail_recursing), ec);
                 if (ec && *ec)
                     return;
 
@@ -2973,7 +2961,7 @@ bool copy_file(path const& from, path const& to, unsigned int options, error_cod
         // Create handle_wrappers here so that CloseHandle calls don't clobber error code returned by GetLastError
         handle_wrapper hw_from, hw_to;
 
-        hw_from.handle = create_file_handle(from.c_str(), GENERIC_READ, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS);
+        hw_from.handle = create_file_handle(from.c_str(), FILE_READ_ATTRIBUTES, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS);
 
         FILETIME lwt_from;
         if (hw_from.handle == INVALID_HANDLE_VALUE)
@@ -2987,7 +2975,7 @@ bool copy_file(path const& from, path const& to, unsigned int options, error_cod
         if (!::GetFileTime(hw_from.handle, NULL, NULL, &lwt_from))
             goto fail_last_error;
 
-        hw_to.handle = create_file_handle(to.c_str(), GENERIC_READ, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS);
+        hw_to.handle = create_file_handle(to.c_str(), FILE_READ_ATTRIBUTES, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS);
 
         if (hw_to.handle != INVALID_HANDLE_VALUE)
         {
@@ -3108,9 +3096,9 @@ bool create_directories(path const& p, system::error_code* ec)
     error_code local_ec;
 
     // Find the initial part of the path that exists
-    for (path fname = path_algorithms::filename_v4(parent); parent.has_relative_path(); fname = path_algorithms::filename_v4(parent))
+    for (path fname = parent.filename(); parent.has_relative_path(); fname = parent.filename())
     {
-        if (!fname.empty() && path_algorithms::compare_v4(fname, dot_p) != 0 && path_algorithms::compare_v4(fname, dot_dot_p) != 0)
+        if (!fname.empty() && fname != dot_p && fname != dot_dot_p)
         {
             file_status existing_status = detail::status_impl(parent, &local_ec);
 
@@ -3127,17 +3115,17 @@ bool create_directories(path const& p, system::error_code* ec)
             }
         }
 
-        path_algorithms::decrement_v4(it);
-        parent.remove_filename_and_trailing_separators();
+        --it;
+        parent.remove_filename();
     }
 
     // Create missing directories
     bool created = false;
-    for (; it != e; path_algorithms::increment_v4(it))
+    for (; it != e; ++it)
     {
         path const& fname = *it;
-        path_algorithms::append_v4(parent, fname);
-        if (!fname.empty() && path_algorithms::compare_v4(fname, dot_p) != 0 && path_algorithms::compare_v4(fname, dot_dot_p) != 0)
+        parent /= fname;
+        if (!fname.empty() && fname != dot_p && fname != dot_dot_p)
         {
             created = detail::create_directory(parent, NULL, &local_ec);
             if (BOOST_UNLIKELY(!!local_ec))
@@ -3771,7 +3759,7 @@ std::time_t creation_time(path const& p, system::error_code* ec)
 
     handle_wrapper hw(create_file_handle(
         p.c_str(),
-        GENERIC_READ,
+        FILE_READ_ATTRIBUTES,
         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
         NULL,
         OPEN_EXISTING,
@@ -3785,6 +3773,7 @@ std::time_t creation_time(path const& p, system::error_code* ec)
     }
 
     FILETIME ct;
+
     if (BOOST_UNLIKELY(!::GetFileTime(hw.handle, &ct, NULL, NULL)))
         goto fail;
 
@@ -3828,7 +3817,7 @@ std::time_t last_write_time(path const& p, system::error_code* ec)
 
     handle_wrapper hw(create_file_handle(
         p.c_str(),
-        GENERIC_READ,
+        FILE_READ_ATTRIBUTES,
         FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
         NULL,
         OPEN_EXISTING,
@@ -3842,6 +3831,7 @@ std::time_t last_write_time(path const& p, system::error_code* ec)
     }
 
     FILETIME lwt;
+
     if (BOOST_UNLIKELY(!::GetFileTime(hw.handle, NULL, NULL, &lwt)))
         goto fail;
 
@@ -4073,8 +4063,9 @@ path read_symlink(path const& p, system::error_code* ec)
     DWORD error;
     if (BOOST_UNLIKELY(h.handle == INVALID_HANDLE_VALUE))
     {
-    return_last_error:
         error = ::GetLastError();
+
+    return_error:
         emit_error(error, p, ec, "boost::filesystem::read_symlink");
         return symlink_path;
     }
@@ -4082,7 +4073,10 @@ path read_symlink(path const& p, system::error_code* ec)
     boost::scoped_ptr< reparse_data_buffer_with_storage > buf(new reparse_data_buffer_with_storage);
     DWORD sz = 0u;
     if (BOOST_UNLIKELY(!::DeviceIoControl(h.handle, FSCTL_GET_REPARSE_POINT, NULL, 0, buf.get(), sizeof(*buf), &sz, NULL)))
-        goto return_last_error;
+    {
+        error = ::GetLastError();
+        goto return_error;
+    }
 
     const wchar_t* buffer;
     std::size_t offset, len;
@@ -4324,8 +4318,11 @@ path temp_directory_path(system::error_code* ec)
 #else // Windows
 #if !defined(UNDER_CE)
 
-    static const wchar_t* env_list[] = { L"TMP", L"TEMP", L"LOCALAPPDATA", L"USERPROFILE" };
-    static const wchar_t temp_dir[] = L"Temp";
+    const wchar_t* tmp_env = L"TMP";
+    const wchar_t* temp_env = L"TEMP";
+    const wchar_t* localappdata_env = L"LOCALAPPDATA";
+    const wchar_t* userprofile_env = L"USERPROFILE";
+    const wchar_t* env_list[] = { tmp_env, temp_env, localappdata_env, userprofile_env };
 
     path p;
     for (unsigned int i = 0; i < sizeof(env_list) / sizeof(*env_list); ++i)
@@ -4335,7 +4332,7 @@ path temp_directory_path(system::error_code* ec)
         {
             p = env;
             if (i >= 2)
-                path_algorithms::append_v4(p, temp_dir, temp_dir + (sizeof(temp_dir) / sizeof(*temp_dir) - 1u));
+                p /= L"Temp";
             error_code lcl_ec;
             if (exists(p, lcl_ec) && !lcl_ec && is_directory(p, lcl_ec) && !lcl_ec)
                 break;
@@ -4360,7 +4357,7 @@ path temp_directory_path(system::error_code* ec)
             goto getwindir_error;
 
         p = buf.get(); // do not depend on initial buf size, see ticket #10388
-        path_algorithms::append_v4(p, temp_dir, temp_dir + (sizeof(temp_dir) / sizeof(*temp_dir) - 1u));
+        p /= L"Temp";
     }
 
     return p;
@@ -4406,12 +4403,7 @@ path system_complete(path const& p, system::error_code* ec)
 {
 #ifdef BOOST_POSIX_API
 
-    if (p.empty() || p.is_absolute())
-        return p;
-
-    path res(current_path());
-    path_algorithms::append_v4(res, p);
-    return res;
+    return (p.empty() || p.is_absolute()) ? p : current_path() / p;
 
 #else
     if (p.empty())
@@ -4448,7 +4440,7 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
 
     path::iterator itr(p_end);
     path head(p);
-    for (; !head.empty(); path_algorithms::decrement_v4(itr))
+    for (; !head.empty(); --itr)
     {
         file_status head_status(detail::status_impl(head, &local_ec));
         if (BOOST_UNLIKELY(head_status.type() == fs::status_error))
@@ -4463,11 +4455,11 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
         if (head_status.type() != fs::file_not_found)
             break;
 
-        head.remove_filename_and_trailing_separators();
+        head.remove_filename();
     }
 
     if (head.empty())
-        return path_algorithms::lexically_normal_v4(p);
+        return p.lexically_normal();
 
     path const& dot_p = dot_path();
     path const& dot_dot_p = dot_dot_path();
@@ -4490,7 +4482,7 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
     {
         BOOST_ASSERT(itr != p_end);
         head = *itr;
-        path_algorithms::increment_v4(itr);
+        ++itr;
     }
 
     if (p.has_root_directory())
@@ -4499,7 +4491,7 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
         // Convert generic separator returned by the iterator for the root directory to
         // the preferred separator.
         head += path::preferred_separator;
-        path_algorithms::increment_v4(itr);
+        ++itr;
     }
 
     if (!head.empty())
@@ -4517,30 +4509,30 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
         if (head_status.type() == fs::file_not_found)
         {
             // If the root path does not exist then no path element exists
-            return path_algorithms::lexically_normal_v4(p);
+            return p.lexically_normal();
         }
     }
 
     path const& dot_p = dot_path();
     path const& dot_dot_p = dot_dot_path();
-    for (; itr != p_end; path_algorithms::increment_v4(itr))
+    for (; itr != p_end; ++itr)
     {
         path const& p_elem = *itr;
 
         // Avoid querying status of paths containing dot and dot-dot elements, as this will break
         // if the root name starts with "\\?\".
-        if (path_algorithms::compare_v4(p_elem, dot_p) == 0)
+        if (p_elem == dot_p)
             continue;
 
-        if (path_algorithms::compare_v4(p_elem, dot_dot_p) == 0)
+        if (p_elem == dot_dot_p)
         {
             if (head.has_relative_path())
-                head.remove_filename_and_trailing_separators();
+                head.remove_filename();
 
             continue;
         }
 
-        path_algorithms::append_v4(head, p_elem);
+        head /= p_elem;
 
         file_status head_status(detail::status_impl(head, &local_ec));
         if (BOOST_UNLIKELY(head_status.type() == fs::status_error))
@@ -4554,24 +4546,24 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
 
         if (head_status.type() == fs::file_not_found)
         {
-            head.remove_filename_and_trailing_separators();
+            head.remove_filename();
             break;
         }
     }
 
     if (head.empty())
-        return path_algorithms::lexically_normal_v4(p);
+        return p.lexically_normal();
 
 #endif
 
     path tail;
     bool tail_has_dots = false;
-    for (; itr != p_end; path_algorithms::increment_v4(itr))
+    for (; itr != p_end; ++itr)
     {
         path const& tail_elem = *itr;
-        path_algorithms::append_v4(tail, tail_elem);
+        tail /= tail_elem;
         // for a later optimization, track if any dot or dot-dot elements are present
-        if (!tail_has_dots && (path_algorithms::compare_v4(tail_elem, dot_p) == 0 || path_algorithms::compare_v4(tail_elem, dot_dot_p) == 0))
+        if (!tail_has_dots && (tail_elem == dot_p || tail_elem == dot_dot_p))
             tail_has_dots = true;
     }
 
@@ -4587,11 +4579,11 @@ path weakly_canonical(path const& p, path const& base, system::error_code* ec)
 
     if (BOOST_LIKELY(!tail.empty()))
     {
-        path_algorithms::append_v4(head, tail);
+        head /= tail;
 
         // optimization: only normalize if tail had dot or dot-dot element
         if (tail_has_dots)
-            return path_algorithms::lexically_normal_v4(head);
+            return head.lexically_normal();
     }
 
     return head;
diff --git a/boost_1_82_0/libs/filesystem/src/path.cpp b/boost_1_82_0/libs/filesystem/src/path.cpp
index 1d9748cac7..8d2555bfc8 100644
--- a/boost_1_82_0/libs/filesystem/src/path.cpp
+++ b/boost_1_82_0/libs/filesystem/src/path.cpp
@@ -1,7 +1,7 @@
 //  filesystem path.cpp  -------------------------------------------------------------  //
 
 //  Copyright Beman Dawes 2008
-//  Copyright Andrey Semashev 2021-2023
+//  Copyright Andrey Semashev 2021
 
 //  Distributed under the Boost Software License, Version 1.0.
 //  See http://www.boost.org/LICENSE_1_0.txt
@@ -60,6 +60,7 @@ namespace {
 typedef path::value_type value_type;
 typedef path::string_type string_type;
 typedef string_type::size_type size_type;
+using boost::filesystem::path_detail::substring;
 
 #ifdef BOOST_WINDOWS_API
 
@@ -150,247 +151,31 @@ inline void first_element(string_type const& src, size_type& element_pos, size_t
 
 namespace boost {
 namespace filesystem {
-namespace detail {
 
-// C++14 provides a mismatch algorithm with four iterator arguments(), but earlier
-// standard libraries didn't, so provide this needed functionality.
-inline std::pair< path::iterator, path::iterator > mismatch(path::iterator it1, path::iterator it1end, path::iterator it2, path::iterator it2end)
-{
-    for (; it1 != it1end && it2 != it2end && path_algorithms::compare_v4(*it1, *it2) == 0;)
-    {
-        path_algorithms::increment_v4(it1);
-        path_algorithms::increment_v4(it2);
-    }
-    return std::make_pair(it1, it2);
-}
-
-//  normal  --------------------------------------------------------------------------//
-
-BOOST_FILESYSTEM_DECL path path_algorithms::lexically_normal_v3(path const& p)
-{
-    const value_type* const pathname = p.m_pathname.c_str();
-    const size_type pathname_size = p.m_pathname.size();
-    size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(pathname, pathname_size, root_name_size);
-    path normal(pathname, pathname + root_name_size);
-
-#if defined(BOOST_WINDOWS_API)
-    for (size_type i = 0; i < root_name_size; ++i)
-    {
-        if (normal.m_pathname[i] == path::separator)
-            normal.m_pathname[i] = path::preferred_separator;
-    }
-#endif
-
-    size_type root_path_size = root_name_size;
-    if (root_dir_pos < pathname_size)
-    {
-        root_path_size = root_dir_pos + 1;
-        normal.m_pathname.push_back(path::preferred_separator);
-    }
-
-    size_type i = root_path_size;
-
-    // Skip redundant directory separators after the root directory
-    while (i < pathname_size && detail::is_directory_separator(pathname[i]))
-        ++i;
-
-    if (i < pathname_size)
-    {
-        bool last_element_was_dot = false;
-        while (true)
-        {
-            {
-                const size_type start_pos = i;
-
-                // Find next separator
-                i += find_separator(pathname + i, pathname_size - i);
-
-                const size_type size = i - start_pos;
-
-                // Skip dot elements
-                if (size == 1u && pathname[start_pos] == path::dot)
-                {
-                    last_element_was_dot = true;
-                    goto skip_append;
-                }
-
-                last_element_was_dot = false;
-
-                // Process dot dot elements
-                if (size == 2u && pathname[start_pos] == path::dot && pathname[start_pos + 1] == path::dot && normal.m_pathname.size() > root_path_size)
-                {
-                    // Don't remove previous dot dot elements
-                    const size_type normal_size = normal.m_pathname.size();
-                    size_type filename_size = find_filename_size(normal.m_pathname, root_path_size, normal_size);
-                    size_type pos = normal_size - filename_size;
-                    if (filename_size != 2u || normal.m_pathname[pos] != path::dot || normal.m_pathname[pos + 1] != path::dot)
-                    {
-                        if (pos > root_path_size && detail::is_directory_separator(normal.m_pathname[pos - 1]))
-                            --pos;
-                        normal.m_pathname.erase(normal.m_pathname.begin() + pos , normal.m_pathname.end());
-                        goto skip_append;
-                    }
-                }
-
-                // Append the element
-                path_algorithms::append_separator_if_needed(normal);
-                normal.m_pathname.append(pathname + start_pos, size);
-            }
-
-        skip_append:
-            if (i == pathname_size)
-                break;
-
-            // Skip directory separators, including duplicates
-            while (i < pathname_size && detail::is_directory_separator(pathname[i]))
-                ++i;
-
-            if (i == pathname_size)
-            {
-                // If a path ends with a separator, add a trailing dot element
-                goto append_trailing_dot;
-            }
-        }
-
-        if (normal.empty() || last_element_was_dot)
-        {
-        append_trailing_dot:
-            path_algorithms::append_separator_if_needed(normal);
-            normal.m_pathname.push_back(path::dot);
-        }
-    }
-
-    return normal;
-}
-
-BOOST_FILESYSTEM_DECL path path_algorithms::lexically_normal_v4(path const& p)
-{
-    const value_type* const pathname = p.m_pathname.c_str();
-    const size_type pathname_size = p.m_pathname.size();
-    size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(pathname, pathname_size, root_name_size);
-    path normal(pathname, pathname + root_name_size);
-
-#if defined(BOOST_WINDOWS_API)
-    for (size_type i = 0; i < root_name_size; ++i)
-    {
-        if (normal.m_pathname[i] == path::separator)
-            normal.m_pathname[i] = path::preferred_separator;
-    }
-#endif
-
-    size_type root_path_size = root_name_size;
-    if (root_dir_pos < pathname_size)
-    {
-        root_path_size = root_dir_pos + 1;
-        normal.m_pathname.push_back(path::preferred_separator);
-    }
-
-    size_type i = root_path_size;
-
-    // Skip redundant directory separators after the root directory
-    while (i < pathname_size && detail::is_directory_separator(pathname[i]))
-        ++i;
-
-    if (i < pathname_size)
-    {
-        while (true)
-        {
-            bool last_element_was_dot = false;
-            {
-                const size_type start_pos = i;
-
-                // Find next separator
-                i += find_separator(pathname + i, pathname_size - i);
-
-                const size_type size = i - start_pos;
-
-                // Skip dot elements
-                if (size == 1u && pathname[start_pos] == path::dot)
-                {
-                    last_element_was_dot = true;
-                    goto skip_append;
-                }
-
-                // Process dot dot elements
-                if (size == 2u && pathname[start_pos] == path::dot && pathname[start_pos + 1] == path::dot && normal.m_pathname.size() > root_path_size)
-                {
-                    // Don't remove previous dot dot elements
-                    const size_type normal_size = normal.m_pathname.size();
-                    size_type filename_size = find_filename_size(normal.m_pathname, root_path_size, normal_size);
-                    size_type pos = normal_size - filename_size;
-                    if (filename_size != 2u || normal.m_pathname[pos] != path::dot || normal.m_pathname[pos + 1] != path::dot)
-                    {
-                        if (pos > root_path_size && detail::is_directory_separator(normal.m_pathname[pos - 1]))
-                            --pos;
-                        normal.m_pathname.erase(normal.m_pathname.begin() + pos, normal.m_pathname.end());
-                        goto skip_append;
-                    }
-                }
-
-                // Append the element
-                path_algorithms::append_separator_if_needed(normal);
-                normal.m_pathname.append(pathname + start_pos, size);
-            }
-
-        skip_append:
-            if (i == pathname_size)
-            {
-                // If a path ends with a trailing dot after a directory element, add a trailing separator
-                if (last_element_was_dot && !normal.empty() && !normal.filename_is_dot_dot())
-                    path_algorithms::append_separator_if_needed(normal);
-
-                break;
-            }
-
-            // Skip directory separators, including duplicates
-            while (i < pathname_size && detail::is_directory_separator(pathname[i]))
-                ++i;
-
-            if (i == pathname_size)
-            {
-                // If a path ends with a separator, add a trailing separator
-                if (!normal.empty() && !normal.filename_is_dot_dot())
-                    path_algorithms::append_separator_if_needed(normal);
-                break;
-            }
-        }
-
-        // If the original path was not empty and normalized ended up being empty, make it a dot
-        if (normal.empty())
-            normal.m_pathname.push_back(path::dot);
-    }
-
-    return normal;
-}
-
-//  append  --------------------------------------------------------------------------//
-
-BOOST_FILESYSTEM_DECL void path_algorithms::append_v3(path& p, const value_type* begin, const value_type* end)
+BOOST_FILESYSTEM_DECL void path::append_v3(const value_type* begin, const value_type* end)
 {
     if (begin != end)
     {
-        if (BOOST_LIKELY(begin < p.m_pathname.data() || begin >= (p.m_pathname.data() + p.m_pathname.size())))
+        if (BOOST_LIKELY(begin < m_pathname.data() || begin >= (m_pathname.data() + m_pathname.size())))
         {
             if (!detail::is_directory_separator(*begin))
-                path_algorithms::append_separator_if_needed(p);
-            p.m_pathname.append(begin, end);
+                append_separator_if_needed();
+            m_pathname.append(begin, end);
         }
         else
         {
             // overlapping source
             string_type rhs(begin, end);
-            path_algorithms::append_v3(p, rhs.data(), rhs.data() + rhs.size());
+            append_v3(rhs.data(), rhs.data() + rhs.size());
         }
     }
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::append_v4(path& p, const value_type* begin, const value_type* end)
+BOOST_FILESYSTEM_DECL void path::append_v4(const value_type* begin, const value_type* end)
 {
     if (begin != end)
     {
-        if (BOOST_LIKELY(begin < p.m_pathname.data() || begin >= (p.m_pathname.data() + p.m_pathname.size())))
+        if (BOOST_LIKELY(begin < m_pathname.data() || begin >= (m_pathname.data() + m_pathname.size())))
         {
             const size_type that_size = end - begin;
             size_type that_root_name_size = 0;
@@ -406,17 +191,17 @@ BOOST_FILESYSTEM_DECL void path_algorithms::append_v4(path& p, const value_type*
             )
             {
             return_assign:
-                p.assign(begin, end);
+                assign(begin, end);
                 return;
             }
 
             size_type this_root_name_size = 0;
-            find_root_directory_start(p.m_pathname.c_str(), p.m_pathname.size(), this_root_name_size);
+            find_root_directory_start(m_pathname.c_str(), m_pathname.size(), this_root_name_size);
 
             if
             (
                 that_root_name_size > 0 &&
-                (that_root_name_size != this_root_name_size || std::memcmp(p.m_pathname.c_str(), begin, this_root_name_size * sizeof(value_type)) != 0)
+                (that_root_name_size != this_root_name_size || std::memcmp(m_pathname.c_str(), begin, this_root_name_size * sizeof(value_type)) != 0)
             )
             {
                 goto return_assign;
@@ -425,219 +210,197 @@ BOOST_FILESYSTEM_DECL void path_algorithms::append_v4(path& p, const value_type*
             if (that_root_dir_pos < that_size)
             {
                 // Remove root directory (if any) and relative path to replace with those from p
-                p.m_pathname.erase(p.m_pathname.begin() + this_root_name_size, p.m_pathname.end());
+                m_pathname.erase(m_pathname.begin() + this_root_name_size, m_pathname.end());
             }
 
             const value_type* const that_path = begin + that_root_name_size;
             if (!detail::is_directory_separator(*that_path))
-                path_algorithms::append_separator_if_needed(p);
-            p.m_pathname.append(that_path, end);
+                append_separator_if_needed();
+            m_pathname.append(that_path, end);
         }
         else
         {
             // overlapping source
             string_type rhs(begin, end);
-            path_algorithms::append_v4(p, rhs.data(), rhs.data() + rhs.size());
+            append_v4(rhs.data(), rhs.data() + rhs.size());
         }
     }
-    else if (path_algorithms::has_filename_v4(p))
+    else if (has_filename_v4())
     {
-        p.m_pathname.push_back(path::preferred_separator);
+        m_pathname.push_back(preferred_separator);
     }
 }
 
-//  compare  -------------------------------------------------------------------------//
+#ifdef BOOST_WINDOWS_API
 
-BOOST_FILESYSTEM_DECL int path_algorithms::lex_compare_v3
-(
-    path_detail::path_iterator first1, path_detail::path_iterator const& last1,
-    path_detail::path_iterator first2, path_detail::path_iterator const& last2
-)
+BOOST_FILESYSTEM_DECL path path::generic_path() const
 {
-    for (; first1 != last1 && first2 != last2;)
-    {
-        if (first1->native() < first2->native())
-            return -1;
-        if (first2->native() < first1->native())
-            return 1;
-        BOOST_ASSERT(first2->native() == first1->native());
-        path_algorithms::increment_v3(first1);
-        path_algorithms::increment_v3(first2);
-    }
-    if (first1 == last1 && first2 == last2)
-        return 0;
-    return first1 == last1 ? -1 : 1;
+    path tmp(*this);
+    std::replace(tmp.m_pathname.begin(), tmp.m_pathname.end(), L'\\', L'/');
+    return tmp;
 }
 
-BOOST_FILESYSTEM_DECL int path_algorithms::lex_compare_v4
-(
-    path_detail::path_iterator first1, path_detail::path_iterator const& last1,
-    path_detail::path_iterator first2, path_detail::path_iterator const& last2
-)
-{
-    for (; first1 != last1 && first2 != last2;)
-    {
-        if (first1->native() < first2->native())
-            return -1;
-        if (first2->native() < first1->native())
-            return 1;
-        BOOST_ASSERT(first2->native() == first1->native());
-        path_algorithms::increment_v4(first1);
-        path_algorithms::increment_v4(first2);
-    }
-    if (first1 == last1 && first2 == last2)
-        return 0;
-    return first1 == last1 ? -1 : 1;
-}
+#endif // BOOST_WINDOWS_API
 
-BOOST_FILESYSTEM_DECL int path_algorithms::compare_v3(path const& left, path const& right)
+BOOST_FILESYSTEM_DECL int path::compare_v3(path const& p) const
 {
-    return path_algorithms::lex_compare_v3(left.begin(), left.end(), right.begin(), right.end());
+    return detail::lex_compare_v3(begin(), end(), p.begin(), p.end());
 }
 
-BOOST_FILESYSTEM_DECL int path_algorithms::compare_v4(path const& left, path const& right)
+BOOST_FILESYSTEM_DECL int path::compare_v4(path const& p) const
 {
-    return path_algorithms::lex_compare_v4(left.begin(), left.end(), right.begin(), right.end());
+    return detail::lex_compare_v4(begin(), end(), p.begin(), p.end());
 }
 
-//  append_separator_if_needed  ------------------------------------------------------//
+//  append_separator_if_needed  ----------------------------------------------------//
 
-BOOST_FILESYSTEM_DECL path_algorithms::string_type::size_type path_algorithms::append_separator_if_needed(path& p)
+BOOST_FILESYSTEM_DECL path::string_type::size_type path::append_separator_if_needed()
 {
-    if (!p.m_pathname.empty() &&
+    if (!m_pathname.empty() &&
 #ifdef BOOST_WINDOWS_API
-        *(p.m_pathname.end() - 1) != colon &&
+        *(m_pathname.end() - 1) != colon &&
 #endif
-        !detail::is_directory_separator(*(p.m_pathname.end() - 1)))
+        !detail::is_directory_separator(*(m_pathname.end() - 1)))
     {
-        string_type::size_type tmp(p.m_pathname.size());
-        p.m_pathname.push_back(path::preferred_separator);
+        string_type::size_type tmp(m_pathname.size());
+        m_pathname += preferred_separator;
         return tmp;
     }
     return 0;
 }
 
-//  erase_redundant_separator  -------------------------------------------------------//
+//  erase_redundant_separator  -----------------------------------------------------//
 
-BOOST_FILESYSTEM_DECL void path_algorithms::erase_redundant_separator(path& p, string_type::size_type sep_pos)
+BOOST_FILESYSTEM_DECL void path::erase_redundant_separator(string_type::size_type sep_pos)
 {
-    if (sep_pos                                          // a separator was added
-        && sep_pos < p.m_pathname.size()                 // and something was appended
-        && (p.m_pathname[sep_pos + 1] == path::separator // and it was also separator
+    if (sep_pos                                  // a separator was added
+        && sep_pos < m_pathname.size()           // and something was appended
+        && (m_pathname[sep_pos + 1] == separator // and it was also separator
 #ifdef BOOST_WINDOWS_API
-            || p.m_pathname[sep_pos + 1] == path::preferred_separator // or preferred_separator
+            || m_pathname[sep_pos + 1] == preferred_separator // or preferred_separator
 #endif
             ))
     {
-        p.m_pathname.erase(p.m_pathname.begin() + sep_pos); // erase the added separator
+        m_pathname.erase(m_pathname.begin() + sep_pos); // erase the added separator
     }
 }
 
 //  modifiers  -----------------------------------------------------------------------//
 
-BOOST_FILESYSTEM_DECL void path_algorithms::remove_filename_v3(path& p)
+#ifdef BOOST_WINDOWS_API
+BOOST_FILESYSTEM_DECL path& path::make_preferred()
+{
+    std::replace(m_pathname.begin(), m_pathname.end(), L'/', L'\\');
+    return *this;
+}
+#endif
+
+BOOST_FILESYSTEM_DECL path& path::remove_filename()
 {
-    p.remove_filename_and_trailing_separators();
+    size_type end_pos = find_parent_path_size();
+    m_pathname.erase(m_pathname.begin() + end_pos, m_pathname.end());
+    return *this;
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::remove_filename_v4(path& p)
+BOOST_FILESYSTEM_DECL path& path::remove_trailing_separator()
 {
-    size_type filename_size = path_algorithms::find_filename_v4_size(p);
-    p.m_pathname.erase(p.m_pathname.begin() + (p.m_pathname.size() - filename_size), p.m_pathname.end());
+    if (!m_pathname.empty() && detail::is_directory_separator(m_pathname[m_pathname.size() - 1]))
+        m_pathname.erase(m_pathname.end() - 1);
+    return *this;
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::replace_extension_v3(path& p, path const& new_extension)
+BOOST_FILESYSTEM_DECL void path::replace_extension_v3(path const& new_extension)
 {
     // erase existing extension, including the dot, if any
-    size_type ext_pos = p.m_pathname.size() - path_algorithms::extension_v3(p).m_pathname.size();
-    p.m_pathname.erase(p.m_pathname.begin() + ext_pos, p.m_pathname.end());
+    size_type ext_pos = m_pathname.size() - extension_v3().m_pathname.size();
+    m_pathname.erase(m_pathname.begin() + ext_pos, m_pathname.end());
 
     if (!new_extension.empty())
     {
         // append new_extension, adding the dot if necessary
-        if (new_extension.m_pathname[0] != path::dot)
-            p.m_pathname.push_back(path::dot);
-        p.m_pathname.append(new_extension.m_pathname);
+        if (new_extension.m_pathname[0] != dot)
+            m_pathname.push_back(dot);
+        m_pathname.append(new_extension.m_pathname);
     }
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::replace_extension_v4(path& p, path const& new_extension)
+BOOST_FILESYSTEM_DECL void path::replace_extension_v4(path const& new_extension)
 {
     // erase existing extension, including the dot, if any
-    size_type ext_pos = p.m_pathname.size() - path_algorithms::find_extension_v4_size(p);
-    p.m_pathname.erase(p.m_pathname.begin() + ext_pos, p.m_pathname.end());
+    size_type ext_pos = m_pathname.size() - find_extension_v4_size();
+    m_pathname.erase(m_pathname.begin() + ext_pos, m_pathname.end());
 
     if (!new_extension.empty())
     {
         // append new_extension, adding the dot if necessary
-        if (new_extension.m_pathname[0] != path::dot)
-            p.m_pathname.push_back(path::dot);
-        p.m_pathname.append(new_extension.m_pathname);
+        if (new_extension.m_pathname[0] != dot)
+            m_pathname.push_back(dot);
+        m_pathname.append(new_extension.m_pathname);
     }
 }
 
 //  decomposition  -------------------------------------------------------------------//
 
-BOOST_FILESYSTEM_DECL size_type path_algorithms::find_root_name_size(path const& p)
+BOOST_FILESYSTEM_DECL size_type path::find_root_name_size() const
 {
     size_type root_name_size = 0;
-    find_root_directory_start(p.m_pathname.c_str(), p.m_pathname.size(), root_name_size);
+    find_root_directory_start(m_pathname.c_str(), m_pathname.size(), root_name_size);
     return root_name_size;
 }
 
-BOOST_FILESYSTEM_DECL size_type path_algorithms::find_root_path_size(path const& p)
+BOOST_FILESYSTEM_DECL size_type path::find_root_path_size() const
 {
     size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(p.m_pathname.c_str(), p.m_pathname.size(), root_name_size);
+    size_type root_dir_pos = find_root_directory_start(m_pathname.c_str(), m_pathname.size(), root_name_size);
 
     size_type size = root_name_size;
-    if (root_dir_pos < p.m_pathname.size())
+    if (root_dir_pos < m_pathname.size())
         size = root_dir_pos + 1;
 
     return size;
 }
 
-BOOST_FILESYSTEM_DECL path_algorithms::substring path_algorithms::find_root_directory(path const& p)
+BOOST_FILESYSTEM_DECL substring path::find_root_directory() const
 {
     substring root_dir;
     size_type root_name_size = 0;
-    root_dir.pos = find_root_directory_start(p.m_pathname.c_str(), p.m_pathname.size(), root_name_size);
-    root_dir.size = static_cast< std::size_t >(root_dir.pos < p.m_pathname.size());
+    root_dir.pos = find_root_directory_start(m_pathname.c_str(), m_pathname.size(), root_name_size);
+    root_dir.size = static_cast< std::size_t >(root_dir.pos < m_pathname.size());
     return root_dir;
 }
 
-BOOST_FILESYSTEM_DECL path_algorithms::substring path_algorithms::find_relative_path(path const& p)
+BOOST_FILESYSTEM_DECL substring path::find_relative_path() const
 {
     size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(p.m_pathname.c_str(), p.m_pathname.size(), root_name_size);
+    size_type root_dir_pos = find_root_directory_start(m_pathname.c_str(), m_pathname.size(), root_name_size);
 
     // Skip root name, root directory and any duplicate separators
     size_type size = root_name_size;
-    if (root_dir_pos < p.m_pathname.size())
+    if (root_dir_pos < m_pathname.size())
     {
         size = root_dir_pos + 1;
 
-        for (size_type n = p.m_pathname.size(); size < n; ++size)
+        for (size_type n = m_pathname.size(); size < n; ++size)
         {
-            if (!detail::is_directory_separator(p.m_pathname[size]))
+            if (!detail::is_directory_separator(m_pathname[size]))
                 break;
         }
     }
 
     substring rel_path;
     rel_path.pos = size;
-    rel_path.size = p.m_pathname.size() - size;
+    rel_path.size = m_pathname.size() - size;
 
     return rel_path;
 }
 
-BOOST_FILESYSTEM_DECL path_algorithms::string_type::size_type path_algorithms::find_parent_path_size(path const& p)
+BOOST_FILESYSTEM_DECL string_type::size_type path::find_parent_path_size() const
 {
-    const size_type size = p.m_pathname.size();
+    const size_type size = m_pathname.size();
     size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(p.m_pathname.c_str(), size, root_name_size);
+    size_type root_dir_pos = find_root_directory_start(m_pathname.c_str(), size, root_name_size);
 
-    size_type filename_size = find_filename_size(p.m_pathname, root_name_size, size);
+    size_type filename_size = find_filename_size(m_pathname, root_name_size, size);
     size_type end_pos = size - filename_size;
     while (true)
     {
@@ -651,7 +414,7 @@ BOOST_FILESYSTEM_DECL path_algorithms::string_type::size_type path_algorithms::f
 
         --end_pos;
 
-        if (!detail::is_directory_separator(p.m_pathname[end_pos]))
+        if (!detail::is_directory_separator(m_pathname[end_pos]))
         {
             ++end_pos;
             break;
@@ -668,13 +431,13 @@ BOOST_FILESYSTEM_DECL path_algorithms::string_type::size_type path_algorithms::f
     return end_pos;
 }
 
-BOOST_FILESYSTEM_DECL path path_algorithms::filename_v3(path const& p)
+BOOST_FILESYSTEM_DECL path path::filename_v3() const
 {
-    const size_type size = p.m_pathname.size();
+    const size_type size = m_pathname.size();
     size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(p.m_pathname.c_str(), size, root_name_size);
+    size_type root_dir_pos = find_root_directory_start(m_pathname.c_str(), size, root_name_size);
     size_type filename_size, pos;
-    if (root_dir_pos < size && detail::is_directory_separator(p.m_pathname[size - 1]) && is_root_separator(p.m_pathname, root_dir_pos, size - 1))
+    if (root_dir_pos < size && detail::is_directory_separator(m_pathname[size - 1]) && is_root_separator(m_pathname, root_dir_pos, size - 1))
     {
         // Return root directory
         pos = root_dir_pos;
@@ -688,160 +451,335 @@ BOOST_FILESYSTEM_DECL path path_algorithms::filename_v3(path const& p)
     }
     else
     {
-        filename_size = find_filename_size(p.m_pathname, root_name_size, size);
+        filename_size = find_filename_size(m_pathname, root_name_size, size);
         pos = size - filename_size;
-        if (filename_size == 0u && pos > root_name_size && detail::is_directory_separator(p.m_pathname[pos - 1]) && !is_root_separator(p.m_pathname, root_dir_pos, pos - 1))
+        if (filename_size == 0u && pos > root_name_size && detail::is_directory_separator(m_pathname[pos - 1]) && !is_root_separator(m_pathname, root_dir_pos, pos - 1))
             return detail::dot_path();
     }
 
-    const value_type* ptr = p.m_pathname.c_str() + pos;
-    return path(ptr, ptr + filename_size);
+    const value_type* p = m_pathname.c_str() + pos;
+    return path(p, p + filename_size);
+}
+
+BOOST_FILESYSTEM_DECL string_type::size_type path::find_filename_v4_size() const
+{
+    const size_type size = m_pathname.size();
+    size_type root_name_size = 0;
+    find_root_directory_start(m_pathname.c_str(), size, root_name_size);
+    return find_filename_size(m_pathname, root_name_size, size);
+}
+
+BOOST_FILESYSTEM_DECL path path::stem_v3() const
+{
+    path name(filename_v3());
+    if (name != detail::dot_path() && name != detail::dot_dot_path())
+    {
+        size_type pos = name.m_pathname.rfind(dot);
+        if (pos != string_type::npos)
+            name.m_pathname.erase(name.m_pathname.begin() + pos, name.m_pathname.end());
+    }
+    return name;
+}
+
+BOOST_FILESYSTEM_DECL path path::stem_v4() const
+{
+    path name(filename_v4());
+    if (name != detail::dot_path() && name != detail::dot_dot_path())
+    {
+        size_type pos = name.m_pathname.rfind(dot);
+        if (pos != 0 && pos != string_type::npos)
+            name.m_pathname.erase(name.m_pathname.begin() + pos, name.m_pathname.end());
+    }
+    return name;
+}
+
+BOOST_FILESYSTEM_DECL path path::extension_v3() const
+{
+    path name(filename_v3());
+    if (name == detail::dot_path() || name == detail::dot_dot_path())
+        return path();
+    size_type pos(name.m_pathname.rfind(dot));
+    return pos == string_type::npos ? path() : path(name.m_pathname.c_str() + pos);
+}
+
+BOOST_FILESYSTEM_DECL string_type::size_type path::find_extension_v4_size() const
+{
+    const size_type size = m_pathname.size();
+    size_type root_name_size = 0;
+    find_root_directory_start(m_pathname.c_str(), size, root_name_size);
+    size_type filename_size = find_filename_size(m_pathname, root_name_size, size);
+    size_type filename_pos = size - filename_size;
+    if
+    (
+        filename_size > 0u &&
+        // Check for "." and ".." filenames
+        !(m_pathname[filename_pos] == dot &&
+            (filename_size == 1u || (filename_size == 2u && m_pathname[filename_pos + 1u] == dot)))
+    )
+    {
+        size_type ext_pos = size;
+        while (ext_pos > filename_pos)
+        {
+            --ext_pos;
+            if (m_pathname[ext_pos] == dot)
+                break;
+        }
+
+        if (ext_pos > filename_pos)
+            return size - ext_pos;
+    }
+
+    return 0u;
+}
+
+//  lexical operations  --------------------------------------------------------------//
+
+namespace detail {
+// C++14 provides a mismatch algorithm with four iterator arguments(), but earlier
+// standard libraries didn't, so provide this needed functionality.
+inline std::pair< path::iterator, path::iterator > mismatch(path::iterator it1, path::iterator it1end, path::iterator it2, path::iterator it2end)
+{
+    for (; it1 != it1end && it2 != it2end && *it1 == *it2;)
+    {
+        ++it1;
+        ++it2;
+    }
+    return std::make_pair(it1, it2);
+}
+} // namespace detail
+
+BOOST_FILESYSTEM_DECL path path::lexically_relative(path const& base) const
+{
+    path::iterator b = begin(), e = end(), base_b = base.begin(), base_e = base.end();
+    std::pair< path::iterator, path::iterator > mm = detail::mismatch(b, e, base_b, base_e);
+    if (mm.first == b && mm.second == base_b)
+        return path();
+    if (mm.first == e && mm.second == base_e)
+        return detail::dot_path();
+
+    std::ptrdiff_t n = 0;
+    for (; mm.second != base_e; ++mm.second)
+    {
+        path const& p = *mm.second;
+        if (p == detail::dot_dot_path())
+            --n;
+        else if (!p.empty() && p != detail::dot_path())
+            ++n;
+    }
+    if (n < 0)
+        return path();
+    if (n == 0 && (mm.first == e || mm.first->empty()))
+        return detail::dot_path();
+
+    path tmp;
+    for (; n > 0; --n)
+        tmp /= detail::dot_dot_path();
+    for (; mm.first != e; ++mm.first)
+        tmp /= *mm.first;
+    return tmp;
+}
+
+//  normal  --------------------------------------------------------------------------//
+
+BOOST_FILESYSTEM_DECL path path::lexically_normal_v3() const
+{
+    const value_type* const pathname = m_pathname.c_str();
+    const size_type pathname_size = m_pathname.size();
+    size_type root_name_size = 0;
+    size_type root_dir_pos = find_root_directory_start(pathname, pathname_size, root_name_size);
+    path normal(pathname, pathname + root_name_size);
+
+#if defined(BOOST_WINDOWS_API)
+    for (size_type i = 0; i < root_name_size; ++i)
+    {
+        if (normal.m_pathname[i] == path::separator)
+            normal.m_pathname[i] = path::preferred_separator;
+    }
+#endif
+
+    size_type root_path_size = root_name_size;
+    if (root_dir_pos < pathname_size)
+    {
+        root_path_size = root_dir_pos + 1;
+        normal.m_pathname.push_back(preferred_separator);
+    }
+
+    size_type i = root_path_size;
+
+    // Skip redundant directory separators after the root directory
+    while (i < pathname_size && detail::is_directory_separator(pathname[i]))
+        ++i;
+
+    if (i < pathname_size)
+    {
+        bool last_element_was_dot = false;
+        while (true)
+        {
+            {
+                const size_type start_pos = i;
+
+                // Find next separator
+                i += find_separator(pathname + i, pathname_size - i);
+
+                const size_type size = i - start_pos;
+
+                // Skip dot elements
+                if (size == 1u && pathname[start_pos] == dot)
+                {
+                    last_element_was_dot = true;
+                    goto skip_append;
+                }
+
+                last_element_was_dot = false;
+
+                // Process dot dot elements
+                if (size == 2u && pathname[start_pos] == dot && pathname[start_pos + 1] == dot && normal.m_pathname.size() > root_path_size)
+                {
+                    // Don't remove previous dot dot elements
+                    const size_type normal_size = normal.m_pathname.size();
+                    size_type filename_size = find_filename_size(normal.m_pathname, root_path_size, normal_size);
+                    size_type pos = normal_size - filename_size;
+                    if (filename_size != 2u || normal.m_pathname[pos] != dot || normal.m_pathname[pos + 1] != dot)
+                    {
+                        if (pos > root_path_size && detail::is_directory_separator(normal.m_pathname[pos - 1]))
+                            --pos;
+                        normal.m_pathname.erase(normal.m_pathname.begin() + pos , normal.m_pathname.end());
+                        goto skip_append;
+                    }
+                }
+
+                // Append the element
+                normal.append_separator_if_needed();
+                normal.m_pathname.append(pathname + start_pos, size);
+            }
+
+        skip_append:
+            if (i == pathname_size)
+                break;
+
+            // Skip directory separators, including duplicates
+            while (i < pathname_size && detail::is_directory_separator(pathname[i]))
+                ++i;
+
+            if (i == pathname_size)
+            {
+                // If a path ends with a separator, add a trailing dot element
+                goto append_trailing_dot;
+            }
+        }
+
+        if (normal.empty() || last_element_was_dot)
+        {
+        append_trailing_dot:
+            normal.append_separator_if_needed();
+            normal.m_pathname.push_back(dot);
+        }
+    }
+
+    return normal;
 }
 
-BOOST_FILESYSTEM_DECL path_algorithms::string_type::size_type path_algorithms::find_filename_v4_size(path const& p)
+BOOST_FILESYSTEM_DECL path path::lexically_normal_v4() const
 {
-    const size_type size = p.m_pathname.size();
+    const value_type* const pathname = m_pathname.c_str();
+    const size_type pathname_size = m_pathname.size();
     size_type root_name_size = 0;
-    find_root_directory_start(p.m_pathname.c_str(), size, root_name_size);
-    return find_filename_size(p.m_pathname, root_name_size, size);
-}
+    size_type root_dir_pos = find_root_directory_start(pathname, pathname_size, root_name_size);
+    path normal(pathname, pathname + root_name_size);
 
-BOOST_FILESYSTEM_DECL path path_algorithms::stem_v3(path const& p)
-{
-    path name(path_algorithms::filename_v3(p));
-    if (path_algorithms::compare_v4(name, detail::dot_path()) != 0 && path_algorithms::compare_v4(name, detail::dot_dot_path()) != 0)
+#if defined(BOOST_WINDOWS_API)
+    for (size_type i = 0; i < root_name_size; ++i)
     {
-        size_type pos = name.m_pathname.rfind(path::dot);
-        if (pos != string_type::npos)
-            name.m_pathname.erase(name.m_pathname.begin() + pos, name.m_pathname.end());
+        if (normal.m_pathname[i] == path::separator)
+            normal.m_pathname[i] = path::preferred_separator;
     }
-    return name;
-}
+#endif
 
-BOOST_FILESYSTEM_DECL path path_algorithms::stem_v4(path const& p)
-{
-    path name(path_algorithms::filename_v4(p));
-    if (path_algorithms::compare_v4(name, detail::dot_path()) != 0 && path_algorithms::compare_v4(name, detail::dot_dot_path()) != 0)
+    size_type root_path_size = root_name_size;
+    if (root_dir_pos < pathname_size)
     {
-        size_type pos = name.m_pathname.rfind(path::dot);
-        if (pos != 0 && pos != string_type::npos)
-            name.m_pathname.erase(name.m_pathname.begin() + pos, name.m_pathname.end());
+        root_path_size = root_dir_pos + 1;
+        normal.m_pathname.push_back(preferred_separator);
     }
-    return name;
-}
 
-BOOST_FILESYSTEM_DECL path path_algorithms::extension_v3(path const& p)
-{
-    path name(path_algorithms::filename_v3(p));
-    if (path_algorithms::compare_v4(name, detail::dot_path()) == 0 || path_algorithms::compare_v4(name, detail::dot_dot_path()) == 0)
-        return path();
-    size_type pos(name.m_pathname.rfind(path::dot));
-    return pos == string_type::npos ? path() : path(name.m_pathname.c_str() + pos);
-}
+    size_type i = root_path_size;
 
-BOOST_FILESYSTEM_DECL path_algorithms::string_type::size_type path_algorithms::find_extension_v4_size(path const& p)
-{
-    const size_type size = p.m_pathname.size();
-    size_type root_name_size = 0;
-    find_root_directory_start(p.m_pathname.c_str(), size, root_name_size);
-    size_type filename_size = find_filename_size(p.m_pathname, root_name_size, size);
-    size_type filename_pos = size - filename_size;
-    if
-    (
-        filename_size > 0u &&
-        // Check for "." and ".." filenames
-        !(p.m_pathname[filename_pos] == path::dot &&
-            (filename_size == 1u || (filename_size == 2u && p.m_pathname[filename_pos + 1u] == path::dot)))
-    )
+    // Skip redundant directory separators after the root directory
+    while (i < pathname_size && detail::is_directory_separator(pathname[i]))
+        ++i;
+
+    if (i < pathname_size)
     {
-        size_type ext_pos = size;
-        while (ext_pos > filename_pos)
+        while (true)
         {
-            --ext_pos;
-            if (p.m_pathname[ext_pos] == path::dot)
-                break;
-        }
-
-        if (ext_pos > filename_pos)
-            return size - ext_pos;
-    }
-
-    return 0u;
-}
+            bool last_element_was_dot = false;
+            {
+                const size_type start_pos = i;
 
-} // namespace detail
+                // Find next separator
+                i += find_separator(pathname + i, pathname_size - i);
 
-BOOST_FILESYSTEM_DECL path& path::remove_filename_and_trailing_separators()
-{
-    size_type end_pos = detail::path_algorithms::find_parent_path_size(*this);
-    m_pathname.erase(m_pathname.begin() + end_pos, m_pathname.end());
-    return *this;
-}
+                const size_type size = i - start_pos;
 
-BOOST_FILESYSTEM_DECL path& path::remove_trailing_separator()
-{
-    if (!m_pathname.empty() && detail::is_directory_separator(m_pathname[m_pathname.size() - 1]))
-        m_pathname.erase(m_pathname.end() - 1);
-    return *this;
-}
+                // Skip dot elements
+                if (size == 1u && pathname[start_pos] == dot)
+                {
+                    last_element_was_dot = true;
+                    goto skip_append;
+                }
 
-BOOST_FILESYSTEM_DECL path& path::replace_filename(path const& replacement)
-{
-    detail::path_algorithms::remove_filename_v4(*this);
-    detail::path_algorithms::append_v4(*this, replacement.m_pathname.data(), replacement.m_pathname.data() + replacement.m_pathname.size());
-    return *this;
-}
+                // Process dot dot elements
+                if (size == 2u && pathname[start_pos] == dot && pathname[start_pos + 1] == dot && normal.m_pathname.size() > root_path_size)
+                {
+                    // Don't remove previous dot dot elements
+                    const size_type normal_size = normal.m_pathname.size();
+                    size_type filename_size = find_filename_size(normal.m_pathname, root_path_size, normal_size);
+                    size_type pos = normal_size - filename_size;
+                    if (filename_size != 2u || normal.m_pathname[pos] != dot || normal.m_pathname[pos + 1] != dot)
+                    {
+                        if (pos > root_path_size && detail::is_directory_separator(normal.m_pathname[pos - 1]))
+                            --pos;
+                        normal.m_pathname.erase(normal.m_pathname.begin() + pos, normal.m_pathname.end());
+                        goto skip_append;
+                    }
+                }
 
-//  lexical operations  --------------------------------------------------------------//
+                // Append the element
+                normal.append_separator_if_needed();
+                normal.m_pathname.append(pathname + start_pos, size);
+            }
 
-BOOST_FILESYSTEM_DECL path path::lexically_relative(path const& base) const
-{
-    path::iterator b = begin(), e = end(), base_b = base.begin(), base_e = base.end();
-    std::pair< path::iterator, path::iterator > mm = detail::mismatch(b, e, base_b, base_e);
-    if (mm.first == b && mm.second == base_b)
-        return path();
-    if (mm.first == e && mm.second == base_e)
-        return detail::dot_path();
+        skip_append:
+            if (i == pathname_size)
+            {
+                // If a path ends with a trailing dot after a directory element, add a trailing separator
+                if (last_element_was_dot && !normal.empty() && !normal.filename_is_dot_dot())
+                    normal.append_separator_if_needed();
 
-    std::ptrdiff_t n = 0;
-    for (; mm.second != base_e; detail::path_algorithms::increment_v4(mm.second))
-    {
-        path const& p = *mm.second;
-        if (detail::path_algorithms::compare_v4(p, detail::dot_dot_path()) == 0)
-            --n;
-        else if (!p.empty() && detail::path_algorithms::compare_v4(p, detail::dot_path()) != 0)
-            ++n;
-    }
-    if (n < 0)
-        return path();
-    if (n == 0 && (mm.first == e || mm.first->empty()))
-        return detail::dot_path();
+                break;
+            }
 
-    path tmp;
-    for (; n > 0; --n)
-        detail::path_algorithms::append_v4(tmp, detail::dot_dot_path());
-    for (; mm.first != e; detail::path_algorithms::increment_v4(mm.first))
-        detail::path_algorithms::append_v4(tmp, *mm.first);
-    return tmp;
-}
+            // Skip directory separators, including duplicates
+            while (i < pathname_size && detail::is_directory_separator(pathname[i]))
+                ++i;
 
-#if defined(BOOST_WINDOWS_API)
+            if (i == pathname_size)
+            {
+                // If a path ends with a separator, add a trailing separator
+                if (!normal.empty() && !normal.filename_is_dot_dot())
+                    normal.append_separator_if_needed();
+                break;
+            }
+        }
 
-BOOST_FILESYSTEM_DECL path path::generic_path() const
-{
-    path tmp(*this);
-    std::replace(tmp.m_pathname.begin(), tmp.m_pathname.end(), L'\\', L'/');
-    return tmp;
-}
+        // If the original path was not empty and normalized ended up being empty, make it a dot
+        if (normal.empty())
+            normal.m_pathname.push_back(dot);
+    }
 
-BOOST_FILESYSTEM_DECL path& path::make_preferred()
-{
-    std::replace(m_pathname.begin(), m_pathname.end(), L'/', L'\\');
-    return *this;
+    return normal;
 }
 
-#endif // defined(BOOST_WINDOWS_API)
-
 } // namespace filesystem
 } // namespace boost
 
@@ -984,13 +922,7 @@ find_next_separator:
     return pos;
 }
 
-//--------------------------------------------------------------------------------------//
-//                                                                                      //
-//                        class path::iterator implementation                           //
-//                                                                                      //
-//--------------------------------------------------------------------------------------//
-
-//  first_element ----------------------------------------------------------------------//
+//  first_element --------------------------------------------------------------------//
 
 //   sets pos and len of first element, excluding extra separators
 //   if src.empty(), sets pos,len, to 0,0.
@@ -1032,153 +964,225 @@ namespace boost {
 namespace filesystem {
 namespace detail {
 
-BOOST_FILESYSTEM_DECL void path_algorithms::increment_v3(path_detail::path_iterator& it)
+BOOST_FILESYSTEM_DECL
+int lex_compare_v3(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
+{
+    for (; first1 != last1 && first2 != last2;)
+    {
+        if (first1->native() < first2->native())
+            return -1;
+        if (first2->native() < first1->native())
+            return 1;
+        BOOST_ASSERT(first2->native() == first1->native());
+        first1.increment_v3();
+        first2.increment_v3();
+    }
+    if (first1 == last1 && first2 == last2)
+        return 0;
+    return first1 == last1 ? -1 : 1;
+}
+
+BOOST_FILESYSTEM_DECL
+int lex_compare_v4(path::iterator first1, path::iterator last1, path::iterator first2, path::iterator last2)
+{
+    for (; first1 != last1 && first2 != last2;)
+    {
+        if (first1->native() < first2->native())
+            return -1;
+        if (first2->native() < first1->native())
+            return 1;
+        BOOST_ASSERT(first2->native() == first1->native());
+        ++first1;
+        ++first2;
+    }
+    if (first1 == last1 && first2 == last2)
+        return 0;
+    return first1 == last1 ? -1 : 1;
+}
+
+} // namespace detail
+
+//--------------------------------------------------------------------------------------//
+//                                                                                      //
+//                        class path::iterator implementation                           //
+//                                                                                      //
+//--------------------------------------------------------------------------------------//
+
+BOOST_FILESYSTEM_DECL path::iterator path::begin() const
+{
+    iterator itr;
+    itr.m_path_ptr = this;
+
+    size_type element_size;
+    first_element(m_pathname, itr.m_pos, element_size);
+
+    if (element_size > 0)
+    {
+        itr.m_element = m_pathname.substr(itr.m_pos, element_size);
+#ifdef BOOST_WINDOWS_API
+        if (itr.m_element.m_pathname.size() == 1u && itr.m_element.m_pathname[0] == preferred_separator)
+            itr.m_element.m_pathname[0] = separator;
+#endif
+    }
+
+    return itr;
+}
+
+BOOST_FILESYSTEM_DECL path::iterator path::end() const
+{
+    iterator itr;
+    itr.m_path_ptr = this;
+    itr.m_pos = m_pathname.size();
+    return itr;
+}
+
+BOOST_FILESYSTEM_DECL void path::iterator::increment_v3()
 {
-    const size_type size = it.m_path_ptr->m_pathname.size();
-    BOOST_ASSERT_MSG(it.m_pos < size, "path::iterator increment past end()");
+    const size_type size = m_path_ptr->m_pathname.size();
+    BOOST_ASSERT_MSG(m_pos < size, "path::iterator increment past end()");
 
     // increment to position past current element; if current element is implicit dot,
     // this will cause m_pos to represent the end iterator
-    it.m_pos += it.m_element.m_pathname.size();
+    m_pos += m_element.m_pathname.size();
 
     // if the end is reached, we are done
-    if (it.m_pos >= size)
+    if (m_pos >= size)
     {
-        BOOST_ASSERT_MSG(it.m_pos == size, "path::iterator increment after the referenced path was modified");
-        it.m_element.clear(); // aids debugging
+        BOOST_ASSERT_MSG(m_pos == size, "path::iterator increment after the referenced path was modified");
+        m_element.clear(); // aids debugging
         return;
     }
 
     // process separator (Windows drive spec is only case not a separator)
-    if (detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos]))
+    if (detail::is_directory_separator(m_path_ptr->m_pathname[m_pos]))
     {
         size_type root_name_size = 0;
-        size_type root_dir_pos = find_root_directory_start(it.m_path_ptr->m_pathname.c_str(), size, root_name_size);
+        size_type root_dir_pos = find_root_directory_start(m_path_ptr->m_pathname.c_str(), size, root_name_size);
 
         // detect root directory and set iterator value to the separator if it is
-        if (it.m_pos == root_dir_pos && it.m_element.m_pathname.size() == root_name_size)
+        if (m_pos == root_dir_pos && m_element.m_pathname.size() == root_name_size)
         {
-            it.m_element.m_pathname = path::separator; // generic format; see docs
+            m_element.m_pathname = separator; // generic format; see docs
             return;
         }
 
         // skip separators until m_pos points to the start of the next element
-        while (it.m_pos != size && detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos]))
+        while (m_pos != size && detail::is_directory_separator(m_path_ptr->m_pathname[m_pos]))
         {
-            ++it.m_pos;
+            ++m_pos;
         }
 
         // detect trailing separator, and treat it as ".", per POSIX spec
-        if (it.m_pos == size &&
-            !is_root_separator(it.m_path_ptr->m_pathname, root_dir_pos, it.m_pos - 1))
+        if (m_pos == size &&
+            !is_root_separator(m_path_ptr->m_pathname, root_dir_pos, m_pos - 1))
         {
-            --it.m_pos;
-            it.m_element = detail::dot_path();
+            --m_pos;
+            m_element = detail::dot_path();
             return;
         }
     }
 
     // get m_element
-    size_type end_pos = it.m_path_ptr->m_pathname.find_first_of(separators, it.m_pos);
+    size_type end_pos = m_path_ptr->m_pathname.find_first_of(separators, m_pos);
     if (end_pos == string_type::npos)
         end_pos = size;
-    const path::value_type* p = it.m_path_ptr->m_pathname.c_str();
-    it.m_element.m_pathname.assign(p + it.m_pos, p + end_pos);
+    const path::value_type* p = m_path_ptr->m_pathname.c_str();
+    m_element.m_pathname.assign(p + m_pos, p + end_pos);
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::increment_v4(path_detail::path_iterator& it)
+BOOST_FILESYSTEM_DECL void path::iterator::increment_v4()
 {
-    const size_type size = it.m_path_ptr->m_pathname.size();
-    BOOST_ASSERT_MSG(it.m_pos <= size, "path::iterator increment past end()");
+    const size_type size = m_path_ptr->m_pathname.size();
+    BOOST_ASSERT_MSG(m_pos <= size, "path::iterator increment past end()");
 
-    if (it.m_element.m_pathname.empty() && (it.m_pos + 1) == size && detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos]))
+    if (m_element.m_pathname.empty() && (m_pos + 1) == size && detail::is_directory_separator(m_path_ptr->m_pathname[m_pos]))
     {
         // The iterator was pointing to the last empty element of the path; set to end.
-        it.m_pos = size;
+        m_pos = size;
         return;
     }
 
     // increment to position past current element; if current element is implicit dot,
     // this will cause m_pos to represent the end iterator
-    it.m_pos += it.m_element.m_pathname.size();
+    m_pos += m_element.m_pathname.size();
 
     // if the end is reached, we are done
-    if (it.m_pos >= size)
+    if (m_pos >= size)
     {
-        BOOST_ASSERT_MSG(it.m_pos == size, "path::iterator increment after the referenced path was modified");
-        it.m_element.clear(); // aids debugging
+        BOOST_ASSERT_MSG(m_pos == size, "path::iterator increment after the referenced path was modified");
+        m_element.clear(); // aids debugging
         return;
     }
 
     // process separator (Windows drive spec is only case not a separator)
-    if (detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos]))
+    if (detail::is_directory_separator(m_path_ptr->m_pathname[m_pos]))
     {
         size_type root_name_size = 0;
-        size_type root_dir_pos = find_root_directory_start(it.m_path_ptr->m_pathname.c_str(), size, root_name_size);
+        size_type root_dir_pos = find_root_directory_start(m_path_ptr->m_pathname.c_str(), size, root_name_size);
 
         // detect root directory and set iterator value to the separator if it is
-        if (it.m_pos == root_dir_pos && it.m_element.m_pathname.size() == root_name_size)
+        if (m_pos == root_dir_pos && m_element.m_pathname.size() == root_name_size)
         {
-            it.m_element.m_pathname = path::separator; // generic format; see docs
+            m_element.m_pathname = separator; // generic format; see docs
             return;
         }
 
         // skip separators until m_pos points to the start of the next element
-        while (it.m_pos != size && detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos]))
+        while (m_pos != size && detail::is_directory_separator(m_path_ptr->m_pathname[m_pos]))
         {
-            ++it.m_pos;
+            ++m_pos;
         }
 
         // detect trailing separator
-        if (it.m_pos == size &&
-            !is_root_separator(it.m_path_ptr->m_pathname, root_dir_pos, it.m_pos - 1))
+        if (m_pos == size &&
+            !is_root_separator(m_path_ptr->m_pathname, root_dir_pos, m_pos - 1))
         {
-            --it.m_pos;
-            it.m_element.m_pathname.clear();
+            --m_pos;
+            m_element.m_pathname.clear();
             return;
         }
     }
 
     // get m_element
-    size_type end_pos = it.m_path_ptr->m_pathname.find_first_of(separators, it.m_pos);
+    size_type end_pos = m_path_ptr->m_pathname.find_first_of(separators, m_pos);
     if (end_pos == string_type::npos)
         end_pos = size;
-    const path::value_type* p = it.m_path_ptr->m_pathname.c_str();
-    it.m_element.m_pathname.assign(p + it.m_pos, p + end_pos);
+    const path::value_type* p = m_path_ptr->m_pathname.c_str();
+    m_element.m_pathname.assign(p + m_pos, p + end_pos);
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::decrement_v3(path_detail::path_iterator& it)
+BOOST_FILESYSTEM_DECL void path::iterator::decrement_v3()
 {
-    const size_type size = it.m_path_ptr->m_pathname.size();
-    BOOST_ASSERT_MSG(it.m_pos > 0, "path::iterator decrement past begin()");
-    BOOST_ASSERT_MSG(it.m_pos <= size, "path::iterator decrement after the referenced path was modified");
+    const size_type size = m_path_ptr->m_pathname.size();
+    BOOST_ASSERT_MSG(m_pos > 0, "path::iterator decrement past begin()");
+    BOOST_ASSERT_MSG(m_pos <= size, "path::iterator decrement after the referenced path was modified");
 
     size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(it.m_path_ptr->m_pathname.c_str(), size, root_name_size);
+    size_type root_dir_pos = find_root_directory_start(m_path_ptr->m_pathname.c_str(), size, root_name_size);
 
-    if (root_dir_pos < size && it.m_pos == root_dir_pos)
+    if (root_dir_pos < size && m_pos == root_dir_pos)
     {
         // Was pointing at root directory, decrement to root name
     set_to_root_name:
-        it.m_pos = 0u;
-        const path::value_type* p = it.m_path_ptr->m_pathname.c_str();
-        it.m_element.m_pathname.assign(p, p + root_name_size);
+        m_pos = 0u;
+        const path::value_type* p = m_path_ptr->m_pathname.c_str();
+        m_element.m_pathname.assign(p, p + root_name_size);
         return;
     }
 
     // if at end and there was a trailing non-root '/', return "."
-    if (it.m_pos == size &&
+    if (m_pos == size &&
         size > 1 &&
-        detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos - 1]) &&
-        !is_root_separator(it.m_path_ptr->m_pathname, root_dir_pos, it.m_pos - 1))
+        detail::is_directory_separator(m_path_ptr->m_pathname[m_pos - 1]) &&
+        !is_root_separator(m_path_ptr->m_pathname, root_dir_pos, m_pos - 1))
     {
-        --it.m_pos;
-        it.m_element = detail::dot_path();
+        --m_pos;
+        m_element = detail::dot_path();
         return;
     }
 
     // skip separators unless root directory
-    size_type end_pos = it.m_pos;
+    size_type end_pos = m_pos;
     while (end_pos > root_name_size)
     {
         --end_pos;
@@ -1186,12 +1190,12 @@ BOOST_FILESYSTEM_DECL void path_algorithms::decrement_v3(path_detail::path_itera
         if (end_pos == root_dir_pos)
         {
             // Decremented to the root directory
-            it.m_pos = end_pos;
-            it.m_element.m_pathname = path::separator; // generic format; see docs
+            m_pos = end_pos;
+            m_element.m_pathname = separator; // generic format; see docs
             return;
         }
 
-        if (!detail::is_directory_separator(it.m_path_ptr->m_pathname[end_pos]))
+        if (!detail::is_directory_separator(m_path_ptr->m_pathname[end_pos]))
         {
             ++end_pos;
             break;
@@ -1201,44 +1205,44 @@ BOOST_FILESYSTEM_DECL void path_algorithms::decrement_v3(path_detail::path_itera
     if (end_pos <= root_name_size)
         goto set_to_root_name;
 
-    size_type filename_size = find_filename_size(it.m_path_ptr->m_pathname, root_name_size, end_pos);
-    it.m_pos = end_pos - filename_size;
-    const path::value_type* p = it.m_path_ptr->m_pathname.c_str();
-    it.m_element.m_pathname.assign(p + it.m_pos, p + end_pos);
+    size_type filename_size = find_filename_size(m_path_ptr->m_pathname, root_name_size, end_pos);
+    m_pos = end_pos - filename_size;
+    const path::value_type* p = m_path_ptr->m_pathname.c_str();
+    m_element.m_pathname.assign(p + m_pos, p + end_pos);
 }
 
-BOOST_FILESYSTEM_DECL void path_algorithms::decrement_v4(path_detail::path_iterator& it)
+BOOST_FILESYSTEM_DECL void path::iterator::decrement_v4()
 {
-    const size_type size = it.m_path_ptr->m_pathname.size();
-    BOOST_ASSERT_MSG(it.m_pos > 0, "path::iterator decrement past begin()");
-    BOOST_ASSERT_MSG(it.m_pos <= size, "path::iterator decrement after the referenced path was modified");
+    const size_type size = m_path_ptr->m_pathname.size();
+    BOOST_ASSERT_MSG(m_pos > 0, "path::iterator decrement past begin()");
+    BOOST_ASSERT_MSG(m_pos <= size, "path::iterator decrement after the referenced path was modified");
 
     size_type root_name_size = 0;
-    size_type root_dir_pos = find_root_directory_start(it.m_path_ptr->m_pathname.c_str(), size, root_name_size);
+    size_type root_dir_pos = find_root_directory_start(m_path_ptr->m_pathname.c_str(), size, root_name_size);
 
-    if (root_dir_pos < size && it.m_pos == root_dir_pos)
+    if (root_dir_pos < size && m_pos == root_dir_pos)
     {
         // Was pointing at root directory, decrement to root name
     set_to_root_name:
-        it.m_pos = 0u;
-        const path::value_type* p = it.m_path_ptr->m_pathname.c_str();
-        it.m_element.m_pathname.assign(p, p + root_name_size);
+        m_pos = 0u;
+        const path::value_type* p = m_path_ptr->m_pathname.c_str();
+        m_element.m_pathname.assign(p, p + root_name_size);
         return;
     }
 
     // if at end and there was a trailing '/', return ""
-    if (it.m_pos == size &&
+    if (m_pos == size &&
         size > 1 &&
-        detail::is_directory_separator(it.m_path_ptr->m_pathname[it.m_pos - 1]) &&
-        !is_root_separator(it.m_path_ptr->m_pathname, root_dir_pos, it.m_pos - 1))
+        detail::is_directory_separator(m_path_ptr->m_pathname[m_pos - 1]) &&
+        !is_root_separator(m_path_ptr->m_pathname, root_dir_pos, m_pos - 1))
     {
-        --it.m_pos;
-        it.m_element.m_pathname.clear();
+        --m_pos;
+        m_element.m_pathname.clear();
         return;
     }
 
     // skip separators unless root directory
-    size_type end_pos = it.m_pos;
+    size_type end_pos = m_pos;
     while (end_pos > root_name_size)
     {
         --end_pos;
@@ -1246,12 +1250,12 @@ BOOST_FILESYSTEM_DECL void path_algorithms::decrement_v4(path_detail::path_itera
         if (end_pos == root_dir_pos)
         {
             // Decremented to the root directory
-            it.m_pos = end_pos;
-            it.m_element.m_pathname = path::separator; // generic format; see docs
+            m_pos = end_pos;
+            m_element.m_pathname = separator; // generic format; see docs
             return;
         }
 
-        if (!detail::is_directory_separator(it.m_path_ptr->m_pathname[end_pos]))
+        if (!detail::is_directory_separator(m_path_ptr->m_pathname[end_pos]))
         {
             ++end_pos;
             break;
@@ -1261,42 +1265,10 @@ BOOST_FILESYSTEM_DECL void path_algorithms::decrement_v4(path_detail::path_itera
     if (end_pos <= root_name_size)
         goto set_to_root_name;
 
-    size_type filename_size = find_filename_size(it.m_path_ptr->m_pathname, root_name_size, end_pos);
-    it.m_pos = end_pos - filename_size;
-    const path::value_type* p = it.m_path_ptr->m_pathname.c_str();
-    it.m_element.m_pathname.assign(p + it.m_pos, p + end_pos);
-}
-
-} // namespace detail
-
-//  path iterators  ------------------------------------------------------------------//
-
-BOOST_FILESYSTEM_DECL path::iterator path::begin() const
-{
-    iterator itr;
-    itr.m_path_ptr = this;
-
-    size_type element_size;
-    first_element(m_pathname, itr.m_pos, element_size);
-
-    if (element_size > 0)
-    {
-        itr.m_element = m_pathname.substr(itr.m_pos, element_size);
-#ifdef BOOST_WINDOWS_API
-        if (itr.m_element.m_pathname.size() == 1u && itr.m_element.m_pathname[0] == path::preferred_separator)
-            itr.m_element.m_pathname[0] = path::separator;
-#endif
-    }
-
-    return itr;
-}
-
-BOOST_FILESYSTEM_DECL path::iterator path::end() const
-{
-    iterator itr;
-    itr.m_path_ptr = this;
-    itr.m_pos = m_pathname.size();
-    return itr;
+    size_type filename_size = find_filename_size(m_path_ptr->m_pathname, root_name_size, end_pos);
+    m_pos = end_pos - filename_size;
+    const path::value_type* p = m_path_ptr->m_pathname.c_str();
+    m_element.m_pathname.assign(p + m_pos, p + end_pos);
 }
 
 } // namespace filesystem
diff --git a/boost_1_82_0/libs/filesystem/src/windows_tools.hpp b/boost_1_82_0/libs/filesystem/src/windows_tools.hpp
index 122d5cfc33..0b1d198fc1 100644
--- a/boost_1_82_0/libs/filesystem/src/windows_tools.hpp
+++ b/boost_1_82_0/libs/filesystem/src/windows_tools.hpp
@@ -62,7 +62,7 @@ inline boost::filesystem::perms make_permissions(boost::filesystem::path const&
     boost::filesystem::perms prms = boost::filesystem::owner_read | boost::filesystem::group_read | boost::filesystem::others_read;
     if ((attr & FILE_ATTRIBUTE_READONLY) == 0u)
         prms |= boost::filesystem::owner_write | boost::filesystem::group_write | boost::filesystem::others_write;
-    boost::filesystem::path ext = detail::path_algorithms::extension_v4(p);
+    boost::filesystem::path ext = p.extension();
     wchar_t const* q = ext.c_str();
     if (equal_extension(q, L".exe", L".EXE") || equal_extension(q, L".com", L".COM") || equal_extension(q, L".bat", L".BAT") || equal_extension(q, L".cmd", L".CMD"))
         prms |= boost::filesystem::owner_exe | boost::filesystem::group_exe | boost::filesystem::others_exe;
diff --git a/boost_1_82_0/libs/filesystem/test/Jamfile.v2 b/boost_1_82_0/libs/filesystem/test/Jamfile.v2
index d1ffc2a6f4..e2c3a311b8 100644
--- a/boost_1_82_0/libs/filesystem/test/Jamfile.v2
+++ b/boost_1_82_0/libs/filesystem/test/Jamfile.v2
@@ -84,7 +84,6 @@ run operations_test.cpp : : : <link>shared <define>BOOST_FILESYSTEM_VERSION=4 <t
 run operations_test.cpp : : : <link>static <define>BOOST_FILESYSTEM_VERSION=4 : operations_test_static ;
 run operations_unit_test.cpp : $(HERE) : : <link>shared <define>BOOST_FILESYSTEM_VERSION=4 <test-info>always_show_run_output ;
 run copy_test.cpp : : : <define>BOOST_FILESYSTEM_VERSION=4 ;
-compile-fail cf_path_nullptr_test.cpp ;
 run path_test.cpp : : : <link>shared <define>BOOST_FILESYSTEM_VERSION=4 ;
 run path_test.cpp : : : <link>static <define>BOOST_FILESYSTEM_VERSION=4 : path_test_static ;
 run path_test.cpp : : : <link>shared <define>BOOST_FILESYSTEM_VERSION=3 : path_test_v3 ;
diff --git a/boost_1_82_0/libs/filesystem/test/cf_path_nullptr_test.cpp b/boost_1_82_0/libs/filesystem/test/cf_path_nullptr_test.cpp
deleted file mode 100644
index 09ac56ddc9..0000000000
--- a/boost_1_82_0/libs/filesystem/test/cf_path_nullptr_test.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2023 Andrey Semashev.
-//
-// Distributed under the Boost Software License, Version 1.0.
-//
-// See accompanying file LICENSE_1_0.txt or copy at
-// http://www.boost.org/LICENSE_1_0.txt
-
-#include <boost/filesystem/path.hpp>
-#include <boost/config.hpp>
-
-#if defined(BOOST_NO_CXX11_NULLPTR)
-#error "This test requires support for C++11 nullptr"
-#endif
-
-int main()
-{
-    boost::filesystem::path p(nullptr);
-    p = nullptr;
-}
diff --git a/boost_1_82_0/libs/filesystem/test/operations_test.cpp b/boost_1_82_0/libs/filesystem/test/operations_test.cpp
index 65858a4e60..4e3c2b9660 100644
--- a/boost_1_82_0/libs/filesystem/test/operations_test.cpp
+++ b/boost_1_82_0/libs/filesystem/test/operations_test.cpp
@@ -1232,7 +1232,7 @@ void create_directories_tests()
     BOOST_TEST(!ec);
 
 #ifdef BOOST_POSIX_API
-    if (access("/", W_OK) != 0)
+    if (geteuid() > 0)
     {
         ec.clear();
         BOOST_TEST(!fs::create_directories("/foo", ec)); // may be OK on Windows
diff --git a/boost_1_82_0/libs/filesystem/test/path_test.cpp b/boost_1_82_0/libs/filesystem/test/path_test.cpp
index cd35037988..ce1a36a655 100644
--- a/boost_1_82_0/libs/filesystem/test/path_test.cpp
+++ b/boost_1_82_0/libs/filesystem/test/path_test.cpp
@@ -187,25 +187,6 @@ typedef basic_custom_string< char > custom_string;
 typedef basic_custom_string< wchar_t > wcustom_string;
 typedef basic_custom_string< fs::path::value_type > pcustom_string;
 
-#if defined(__clang__)
-#pragma clang diagnostic push
-// unused function 'to_string'
-#pragma clang diagnostic ignored "-Wunused-function"
-#endif // defined(__clang__)
-
-inline std::string const& to_string(std::string const& s)
-{
-    return s;
-}
-
-inline std::string to_string(fs::path const& p)
-{
-    return p.string();
-}
-
-#if defined(__clang__)
-#pragma clang diagnostic pop
-#endif // defined(__clang__)
 
 std::string platform(BOOST_PLATFORM);
 
@@ -1059,12 +1040,11 @@ void query_and_decomposition_tests()
     p = q = "/";
     BOOST_TEST(p.relative_path().string() == "");
     BOOST_TEST(p.parent_path().string() == "");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
     BOOST_TEST(p.filename() == "/");
     BOOST_TEST(p.stem() == "/");
 #else
-    PATH_TEST_EQ(q.remove_filename().string(), p.string());
     BOOST_TEST(p.filename() == "");
     BOOST_TEST(p.stem() == "");
 #endif
@@ -1093,12 +1073,11 @@ void query_and_decomposition_tests()
     p = q = "//";
     PATH_TEST_EQ(p.relative_path().string(), "");
     PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(p.filename(), "//");
     PATH_TEST_EQ(p.stem(), "//");
 #else
-    PATH_TEST_EQ(q.remove_filename().string(), p.string());
     PATH_TEST_EQ(p.filename(), "");
     PATH_TEST_EQ(p.stem(), "");
 #endif
@@ -1124,12 +1103,11 @@ void query_and_decomposition_tests()
     p = q = "///";
     PATH_TEST_EQ(p.relative_path().string(), "");
     PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(p.filename(), "/");
     PATH_TEST_EQ(p.stem(), "/");
 #else
-    PATH_TEST_EQ(q.remove_filename().string(), p.string());
     PATH_TEST_EQ(p.filename(), "");
     PATH_TEST_EQ(p.stem(), "");
 #endif
@@ -1241,11 +1219,7 @@ void query_and_decomposition_tests()
     p = q = "/foo/";
     PATH_TEST_EQ(p.relative_path().string(), "foo/");
     PATH_TEST_EQ(p.parent_path().string(), "/foo");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), p.string());
-#endif
     PATH_TEST_EQ(p.filename(), BOOST_FILESYSTEM_V3_TRAILING_DOT);
     PATH_TEST_EQ(p.stem(), BOOST_FILESYSTEM_V3_TRAILING_DOT);
     PATH_TEST_EQ(p.extension(), "");
@@ -1273,11 +1247,7 @@ void query_and_decomposition_tests()
     p = q = "///foo";
     PATH_TEST_EQ(p.relative_path().string(), "foo");
     PATH_TEST_EQ(p.parent_path().string(), "/");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), "///");
-#endif
     PATH_TEST_EQ(p.filename(), "foo");
     PATH_TEST_EQ(p.root_name(), "");
     PATH_TEST_EQ(p.root_directory(), "/");
@@ -1296,11 +1266,7 @@ void query_and_decomposition_tests()
     p = q = "foo/bar";
     BOOST_TEST(p.relative_path().string() == "foo/bar");
     BOOST_TEST(p.parent_path().string() == "foo");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), "foo/");
-#endif
     BOOST_TEST(p.filename() == "bar");
     BOOST_TEST(p.stem() == "bar");
     BOOST_TEST(p.extension() == "");
@@ -1320,11 +1286,7 @@ void query_and_decomposition_tests()
     p = q = "../foo";
     BOOST_TEST(p.relative_path().string() == "../foo");
     BOOST_TEST(p.parent_path().string() == "..");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), "../");
-#endif
     BOOST_TEST(p.filename() == "foo");
     BOOST_TEST(p.root_name() == "");
     BOOST_TEST(p.root_directory() == "");
@@ -1340,11 +1302,7 @@ void query_and_decomposition_tests()
     p = q = "..///foo";
     PATH_TEST_EQ(p.relative_path().string(), "..///foo");
     PATH_TEST_EQ(p.parent_path().string(), "..");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), "..///");
-#endif
     PATH_TEST_EQ(p.filename(), "foo");
     PATH_TEST_EQ(p.root_name(), "");
     PATH_TEST_EQ(p.root_directory(), "");
@@ -1360,11 +1318,7 @@ void query_and_decomposition_tests()
     p = q = "/foo/bar";
     BOOST_TEST(p.relative_path().string() == "foo/bar");
     BOOST_TEST(p.parent_path().string() == "/foo");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), "/foo/");
-#endif
     BOOST_TEST(p.filename() == "bar");
     BOOST_TEST(p.root_name() == "");
     BOOST_TEST(p.root_directory() == "/");
@@ -1389,11 +1343,7 @@ void query_and_decomposition_tests()
     p = q = path("//net");
     PATH_TEST_EQ(p.string(), "//net");
     PATH_TEST_EQ(p.relative_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), p.string());
-#endif
     PATH_TEST_EQ(p.parent_path().string(), "");
 #if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(p.filename(), "//net");
@@ -1418,11 +1368,10 @@ void query_and_decomposition_tests()
     p = q = path("//net/");
     BOOST_TEST(p.relative_path().string() == "");
     BOOST_TEST(p.parent_path().string() == "//net");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
     BOOST_TEST(p.filename() == "/");
 #else
-    PATH_TEST_EQ(q.remove_filename().string(), p.string());
     BOOST_TEST(p.filename() == "");
 #endif
     BOOST_TEST(p.root_name() == "//net");
@@ -1459,11 +1408,7 @@ void query_and_decomposition_tests()
     p = q = path("//net///foo");
     PATH_TEST_EQ(p.relative_path().string(), "foo");
     PATH_TEST_EQ(p.parent_path().string(), "//net/");
-#if BOOST_FILESYSTEM_VERSION == 3
     PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-    PATH_TEST_EQ(q.remove_filename().string(), "//net///");
-#endif
     PATH_TEST_EQ(p.filename(), "foo");
     PATH_TEST_EQ(p.root_name(), "//net");
     PATH_TEST_EQ(p.root_directory(), "/");
@@ -1491,12 +1436,11 @@ void query_and_decomposition_tests()
         p = q = path("\\\\?\\");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\\\?\\");
         PATH_TEST_EQ(p.stem(), "\\\\?\\");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
         PATH_TEST_EQ(p.stem(), "");
 #endif
@@ -1522,13 +1466,12 @@ void query_and_decomposition_tests()
         p = q = path("\\\\.\\");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\\\.\\");
         PATH_TEST_EQ(p.stem(), "\\\\");
         PATH_TEST_EQ(p.extension(), ".\\");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
         PATH_TEST_EQ(p.stem(), "");
         PATH_TEST_EQ(p.extension(), "");
@@ -1555,12 +1498,11 @@ void query_and_decomposition_tests()
         p = q = path("\\??\\");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\??\\");
         PATH_TEST_EQ(p.stem(), "\\??\\");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
         PATH_TEST_EQ(p.stem(), "");
 #endif
@@ -1586,11 +1528,10 @@ void query_and_decomposition_tests()
         p = q = path("c:");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "c:");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "c:");
@@ -1611,11 +1552,10 @@ void query_and_decomposition_tests()
         p = q = path("\\\\?\\c:");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\\\?\\c:");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "\\\\?\\c:");
@@ -1636,11 +1576,10 @@ void query_and_decomposition_tests()
         p = q = path("\\\\.\\c:");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\\\.\\c:");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "\\\\.\\c:");
@@ -1661,11 +1600,10 @@ void query_and_decomposition_tests()
         p = q = path("\\??\\c:");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\??\\c:");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "\\??\\c:");
@@ -1750,11 +1688,10 @@ void query_and_decomposition_tests()
         p = q = path("c:/");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "c:");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "/");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "c:");
@@ -1775,11 +1712,10 @@ void query_and_decomposition_tests()
         p = q = path("\\\\?\\c:\\");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "\\\\?\\c:");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "\\\\?\\c:");
@@ -1800,11 +1736,10 @@ void query_and_decomposition_tests()
         p = q = path("\\\\.\\c:\\");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "\\\\.\\c:");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "\\\\.\\c:");
@@ -1825,11 +1760,10 @@ void query_and_decomposition_tests()
         p = q = path("\\??\\c:\\");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "\\??\\c:");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "\\");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "\\??\\c:");
@@ -1882,11 +1816,7 @@ void query_and_decomposition_tests()
         p = q = path("c://foo");
         PATH_TEST_EQ(p.relative_path().string(), "foo");
         PATH_TEST_EQ(p.parent_path().string(), "c:/");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-        PATH_TEST_EQ(q.remove_filename().string(), "c://");
-#endif
         PATH_TEST_EQ(p.filename(), "foo");
         PATH_TEST_EQ(p.root_name(), "c:");
         PATH_TEST_EQ(p.root_directory(), "/");
@@ -1902,11 +1832,7 @@ void query_and_decomposition_tests()
         p = q = path("c:\\foo\\bar");
         PATH_TEST_EQ(p.relative_path().string(), "foo\\bar");
         PATH_TEST_EQ(p.parent_path().string(), "c:\\foo");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-        PATH_TEST_EQ(q.remove_filename().string(), "c:\\foo\\");
-#endif
         PATH_TEST_EQ(p.filename(), "bar");
         PATH_TEST_EQ(p.root_name(), "c:");
         PATH_TEST_EQ(p.root_directory(), "\\");
@@ -1922,11 +1848,7 @@ void query_and_decomposition_tests()
         p = q = path("\\\\?\\c:\\foo\\bar");
         PATH_TEST_EQ(p.relative_path().string(), "foo\\bar");
         PATH_TEST_EQ(p.parent_path().string(), "\\\\?\\c:\\foo");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-        PATH_TEST_EQ(q.remove_filename().string(), "\\\\?\\c:\\foo\\");
-#endif
         PATH_TEST_EQ(p.filename(), "bar");
         PATH_TEST_EQ(p.root_name(), "\\\\?\\c:");
         PATH_TEST_EQ(p.root_directory(), "\\");
@@ -1942,11 +1864,7 @@ void query_and_decomposition_tests()
         p = q = path("\\\\.\\c:\\foo\\bar");
         PATH_TEST_EQ(p.relative_path().string(), "foo\\bar");
         PATH_TEST_EQ(p.parent_path().string(), "\\\\.\\c:\\foo");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-        PATH_TEST_EQ(q.remove_filename().string(), "\\\\.\\c:\\foo\\");
-#endif
         PATH_TEST_EQ(p.filename(), "bar");
         PATH_TEST_EQ(p.root_name(), "\\\\.\\c:");
         PATH_TEST_EQ(p.root_directory(), "\\");
@@ -1962,11 +1880,7 @@ void query_and_decomposition_tests()
         p = q = path("\\??\\c:\\foo\\bar");
         PATH_TEST_EQ(p.relative_path().string(), "foo\\bar");
         PATH_TEST_EQ(p.parent_path().string(), "\\??\\c:\\foo");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-        PATH_TEST_EQ(q.remove_filename().string(), "\\??\\c:\\foo\\");
-#endif
         PATH_TEST_EQ(p.filename(), "bar");
         PATH_TEST_EQ(p.root_name(), "\\??\\c:");
         PATH_TEST_EQ(p.root_directory(), "\\");
@@ -1982,11 +1896,10 @@ void query_and_decomposition_tests()
         p = q = path("prn:");
         PATH_TEST_EQ(p.relative_path().string(), "");
         PATH_TEST_EQ(p.parent_path().string(), "");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
+#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(p.filename(), "prn:");
 #else
-        PATH_TEST_EQ(q.remove_filename().string(), p.string());
         PATH_TEST_EQ(p.filename(), "");
 #endif
         PATH_TEST_EQ(p.root_name(), "prn:");
@@ -2007,11 +1920,7 @@ void query_and_decomposition_tests()
         p = q = path("\\\\net\\\\\\foo");
         PATH_TEST_EQ(p.relative_path().string(), "foo");
         PATH_TEST_EQ(p.parent_path().string(), "\\\\net\\");
-#if BOOST_FILESYSTEM_VERSION == 3
         PATH_TEST_EQ(q.remove_filename().string(), p.parent_path().string());
-#else
-        PATH_TEST_EQ(q.remove_filename().string(), "\\\\net\\\\\\");
-#endif
         PATH_TEST_EQ(p.filename(), "foo");
         PATH_TEST_EQ(p.root_name(), "\\\\net");
         PATH_TEST_EQ(p.root_directory(), "\\");
@@ -2193,11 +2102,6 @@ void construction_tests()
 #if !defined(BOOST_NO_CXX17_HDR_STRING_VIEW)
     PATH_TEST_EQ(std::string_view("foo"), "foo");
 #endif
-
-    // Check that path constructors don't cause ambiguity for to_string calls
-    // https://github.com/boostorg/filesystem/issues/273
-    custom_string c("test");
-    BOOST_TEST_EQ(to_string(c), std::string("test"));
 }
 
 //  append_tests  --------------------------------------------------------------------//
@@ -2420,14 +2324,6 @@ void concat_tests()
 
 //  self_assign_append_concat_tests  -------------------------------------------------//
 
-#if defined(__clang__) && defined(__has_warning)
-#if __has_warning("-Wself-assign-overloaded")
-#pragma clang diagnostic push
-// explicitly assigning value of variable of type 'boost::filesystem::path' to itself
-#pragma clang diagnostic ignored "-Wself-assign-overloaded"
-#endif
-#endif
-
 void self_assign_append_concat_tests()
 {
     std::cout << "self_assign_append_concat_tests..." << std::endl;
@@ -2482,12 +2378,6 @@ void self_assign_append_concat_tests()
     PATH_TEST_EQ(p.concat(p.c_str() + 5, p.c_str() + 7), "snafubarba");
 }
 
-#if defined(__clang__) && defined(__has_warning)
-#if __has_warning("-Wself-assign-overloaded")
-#pragma clang diagnostic pop
-#endif
-#endif
-
 //  name_function_tests  -------------------------------------------------------------//
 
 void name_function_tests()
@@ -2826,14 +2716,6 @@ const boost::filesystem::path ticket_6690("test");       // #6690 another V++ st
 //                                                                                      //
 //--------------------------------------------------------------------------------------//
 
-#if defined(__clang__) && defined(__has_warning)
-#if __has_warning("-Wself-assign-overloaded")
-#pragma clang diagnostic push
-// explicitly assigning value of variable of type 'boost::filesystem::path' to itself
-#pragma clang diagnostic ignored "-Wself-assign-overloaded"
-#endif
-#endif
-
 int cpp_main(int, char*[])
 {
     // The choice of platform is make at runtime rather than compile-time
@@ -2925,9 +2807,3 @@ int cpp_main(int, char*[])
 
     return ::boost::report_errors();
 }
-
-#if defined(__clang__) && defined(__has_warning)
-#if __has_warning("-Wself-assign-overloaded")
-#pragma clang diagnostic pop
-#endif
-#endif
diff --git a/boost_1_82_0/libs/filesystem/test/path_unit_test.cpp b/boost_1_82_0/libs/filesystem/test/path_unit_test.cpp
index a6fc069aa1..28b8aecae5 100644
--- a/boost_1_82_0/libs/filesystem/test/path_unit_test.cpp
+++ b/boost_1_82_0/libs/filesystem/test/path_unit_test.cpp
@@ -228,14 +228,6 @@ void test_constructors()
 path x;
 path y;
 
-#if defined(__clang__) && defined(__has_warning)
-#if __has_warning("-Wself-assign-overloaded")
-#pragma clang diagnostic push
-// explicitly assigning value of variable of type 'boost::filesystem::path' to itself
-#pragma clang diagnostic ignored "-Wself-assign-overloaded"
-#endif
-#endif
-
 //  test_assignments  ----------------------------------------------------------------//
 
 void test_assignments()
@@ -447,12 +439,6 @@ void test_concats()
     PATH_IS(x, L"foo-x");
 }
 
-#if defined(__clang__) && defined(__has_warning)
-#if __has_warning("-Wself-assign-overloaded")
-#pragma clang diagnostic pop
-#endif
-#endif
-
 //  test_observers  ------------------------------------------------------------------//
 
 void test_observers()
@@ -760,35 +746,16 @@ void test_modifiers()
     CHECK(path("").remove_filename() == "");
     CHECK(path("foo").remove_filename() == "");
     CHECK(path("/foo").remove_filename() == "/");
-
-    BOOST_TEST_EQ(path(".").remove_filename(), path(""));
-    BOOST_TEST_EQ(path("/.").remove_filename(), path("/"));
-    BOOST_TEST_EQ(path("..").remove_filename(), path(""));
-    BOOST_TEST_EQ(path("/..").remove_filename(), path("/"));
-
-#if BOOST_FILESYSTEM_VERSION == 3
     CHECK(path("foo/bar").remove_filename() == "foo");
     BOOST_TEST_EQ(path("foo/bar/").remove_filename(), path("foo/bar"));
+    BOOST_TEST_EQ(path(".").remove_filename(), path(""));
     BOOST_TEST_EQ(path("./.").remove_filename(), path("."));
+    BOOST_TEST_EQ(path("/.").remove_filename(), path("/"));
+    BOOST_TEST_EQ(path("..").remove_filename(), path(""));
     BOOST_TEST_EQ(path("../..").remove_filename(), path(".."));
+    BOOST_TEST_EQ(path("/..").remove_filename(), path("/"));
     BOOST_TEST_EQ(path("//").remove_filename(), path(""));
     BOOST_TEST_EQ(path("////").remove_filename(), path(""));
-#else
-    CHECK(path("foo/bar").remove_filename() == "foo/");
-    BOOST_TEST_EQ(path("foo/bar/").remove_filename(), path("foo/bar/"));
-    BOOST_TEST_EQ(path("./.").remove_filename(), path("./"));
-    BOOST_TEST_EQ(path("../..").remove_filename(), path("../"));
-    BOOST_TEST_EQ(path("//").remove_filename(), path("//"));
-    BOOST_TEST_EQ(path("////").remove_filename(), path("////"));
-#endif
-
-    BOOST_TEST_EQ(path("foo/bar").remove_filename_and_trailing_separators(), path("foo"));
-    BOOST_TEST_EQ(path("foo/bar/").remove_filename_and_trailing_separators(), path("foo/bar"));
-    BOOST_TEST_EQ(path("foo///bar").remove_filename_and_trailing_separators(), path("foo"));
-    BOOST_TEST_EQ(path("foo/bar///").remove_filename_and_trailing_separators(), path("foo/bar"));
-
-    BOOST_TEST_EQ(path("foo/bar").replace_filename("zoo"), path("foo/zoo"));
-    BOOST_TEST_EQ(path("foo/bar/").replace_filename("zoo"), path("foo/bar/zoo"));
 }
 
 //  test_decompositions  -------------------------------------------------------------//
